---
title: Number Conversion
excerpt: Number Conversion overview
date: 2023-01-23
type: Docs
category: TypeConversion
tags: typeConversion
---

ECMAScriptæœ‰ä¸¤ç§å†…ç½®çš„æ•°å­—ç±»å‹ï¼š`Number`å’Œ`BigInt`ã€‚ä»¥ä¸‹æŠ½è±¡æ“ä½œæ˜¯åœ¨è¿™äº›æ•°å­—ç±»å‹ä¸Šå®šä¹‰çš„ã€‚
**result** åˆ—æ˜¾ç¤ºè¿”å›ç±»å‹ï¼Œå¹¶æŒ‡ç¤ºæ˜¯å¦å¯èƒ½å¯¹æ“ä½œçš„æŸäº›è°ƒç”¨è¿”å›çªç„¶å®Œæˆã€‚

| Operation     | Example source	 |   Explain  | Result |
| :------------ | :--------------: | :----------- | ----------: |
| [sameValue]  | `Object.is(x,y)` | å¯¹è±¡å†…éƒ¨æ–¹æ³•,é€šè¿‡SameValue(x,y)ï¼Œä»¥æµ‹è¯•ç¡®åˆ‡çš„å€¼ç›¸ç­‰æ€§ | Boolean
| [sameValueZero] | `[x].includes(y)`| Arrayã€Mapå’ŒSetæ–¹æ³•ï¼Œé€šè¿‡SameValueZero(x,y)æµ‹è¯•å€¼ç›¸ç­‰ï¼Œå¿½ç•¥`+0`å’Œ`-0`ä¹‹é—´çš„å·®å¼‚ | Boolean
| [equal] | `x==y`| ç›¸ç­‰è¿ç®—ç¬¦ï¼Œé€šè¿‡[isStrictlyEqual]è°ƒç”¨ | Boolean
| [add] | `x+y`| ç›¸åŠ è¿ç®—ç¬¦ï¼Œé€šè¿‡å‰ç¼€è‡ªå¢ã€åç¼€è‡ªå¢ä»¥åŠç›¸åŠ è°ƒç”¨ | Number



## Number Type

Numberç±»å‹æ˜¯ä¸€ç§[åŸºäºIEEE754æ ‡å‡†çš„åŒç²¾åº¦64ä½äºŒè¿›åˆ¶æ ¼å¼çš„å€¼]()ã€‚
èƒ½å¤Ÿå­˜å‚¨2<sup>-1074</sup> åˆ° 2<sup>1024</sup>ä¹‹é—´çš„æ­£æµ®ç‚¹æ•°, ä»¥åŠ -2<sup>-1074</sup> å’Œ -2<sup>-1024</sup> ä¹‹é—´çš„è´Ÿæµ®ç‚¹æ•°ã€‚
ä½†æ˜¯å®ƒä»…èƒ½å®‰å…¨åœ°å­˜å‚¨åœ¨ - (2<sup>53</sup> - 1) `Number.MIN_SAFE_INTEGER` åˆ° 2<sup>53</sup> - 1 `Number.MAX_SAFE_INTEGER` èŒƒå›´å†…çš„æ•´æ•°ã€‚
è¶…å‡ºè¿™ä¸ªèŒƒå›´ï¼ŒJavaScript å°†ä¸èƒ½å®‰å…¨åœ°è¡¨ç¤ºæ•´æ•°ï¼›
ç›¸åï¼Œå®ƒä»¬å°†ç”±åŒç²¾åº¦æµ®ç‚¹è¿‘ä¼¼è¡¨ç¤ºã€‚ä½ å¯ä»¥ä½¿ç”¨ `Number.isSafeInteger()` æ£€æŸ¥ä¸€ä¸ªæ•°æ˜¯å¦åœ¨å®‰å…¨çš„æ•´æ•°èŒƒå›´å†…ã€‚

Â±(2<sup>-1074</sup> ~ 2<sup>1024</sup>) èŒƒå›´ä¹‹å¤–çš„å€¼ä¼šè‡ªåŠ¨è½¬æ¢ï¼š

- å¤§äº `Number.MAX_VALUE` çš„æ­£å€¼è¢«è½¬æ¢ä¸º `+Infinity`ã€‚
- å°äº `Number.MIN_VALUE` çš„æ­£å€¼è¢«è½¬æ¢ä¸º `+0`ã€‚
- å°äº `-Number.MAX_VALUE` çš„è´Ÿå€¼è¢«è½¬æ¢ä¸º `-Infinity`ã€‚
- å¤§äº `-Number.MIN_VALUE` çš„è´Ÿå€¼è¢«è½¬æ¢ä¸º `-0`ã€‚

`+Infinity` å’Œ `-Infinity` è¡Œä¸ºç±»ä¼¼äºæ•°å­¦ä¸Šçš„æ— ç©·å¤§ï¼Œä½†æ˜¯æœ‰ä¸€äº›ç»†å¾®çš„åŒºåˆ«ï¼›æ›´å¤šç»†èŠ‚ï¼Œå‚è§ `Number.POSITIVE_INFINITY` å’Œ `Number.NEGATIVE_INFINITY`ã€‚

Number ç±»å‹ä»…æœ‰ä¸€ä¸ªå…·æœ‰å¤šä¸ªè¡¨ç°å½¢å¼çš„å€¼ï¼š`0` åŒæ—¶è¡¨ç¤ºä¸º `-0` å’Œ `+0`ï¼ˆå…¶ä¸­ `0` æ˜¯ `+0` çš„åˆ«åï¼‰ã€‚
å®é™…ä¸Šï¼Œè¿™ä¸¤è€…ä¹‹é—´å‡ ä¹æ²¡æœ‰åŒºåˆ«ï¼›ä¾‹å¦‚ï¼Œ`+0 === -0` æ˜¯ `true`ã€‚ç„¶è€Œï¼Œå½“ä½ é™¤ä»¥ `0` çš„æ—¶å€™ï¼Œä½ è¦æ³¨æ„åˆ°è¿™ä¸€ç‚¹ï¼š

```ts
console.log(1/0); // Infinity
console.log(1/-0); // -Infinity
```

`NaNï¼ˆâ€œNot a Numberâ€ï¼‰`æ˜¯ä¸€ä¸ªç‰¹æ®Šç§ç±»çš„æ•°å€¼ï¼Œå½“ç®—æœ¯è¿ç®—çš„ç»“æœä¸è¡¨ç¤ºæ•°å€¼æ—¶ï¼Œé€šå¸¸ä¼šé‡åˆ°å®ƒã€‚**å®ƒä¹Ÿæ˜¯ JavaScript ä¸­å”¯ä¸€ä¸ç­‰äºè‡ªèº«çš„å€¼ã€‚**

**è™½ç„¶ `number` åœ¨æ¦‚å¿µä¸Šæ˜¯ä¸€ä¸ªâ€œæ•°å­¦çš„å€¼â€ï¼Œå¹¶ä¸”æ€»æ˜¯éšå¼çš„ç¼–ç ä¸ºæµ®ç‚¹ç±»å‹ï¼Œä½†æ˜¯ JavaScript æä¾›äº†ä½è¿ç®—ç¬¦ã€‚å½“åº”ç”¨ä½è¿ç®—ç¬¦æ—¶ï¼Œnumber é¦–å…ˆè½¬æ¢ä¸º 32 ä½æ•´æ•°ã€‚**


### add

æŠ½è±¡æ“ä½œ `add` æ¥å—å‚æ•°`x(Number)`å’Œ`y(Number)`ï¼Œå¹¶è¿”å›ä¸€ä¸ªæ•°å­—ã€‚

å®ƒæ ¹æ®[IEEE 754-2019](https://tc39.es/ecma262/#sec-bibliography)äºŒè¿›åˆ¶åŒç²¾åº¦ç®—æœ¯çš„è§„åˆ™è¿›è¡ŒåŠ æ³•ï¼Œäº§ç”Ÿå…¶å‚æ•°çš„æ€»å’Œã€‚è°ƒç”¨æ—¶ï¼Œå®ƒä¼šæ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

ECMAScriptæ–‡æ¡£å§‹ç»ˆæ˜ç¡®è¡¨ç¤ºæ•°å­¦å€¼ä¸`Numbers` æˆ– `BigInts`ä¹‹é—´çš„è½¬æ¢ã€‚

ä»¥ä¸‹æœ‰å‡ ä¸ªå®šä¹‰ï¼š

1. `ğ”½(x)`ï¼šä»æ•°å­¦å€¼æˆ–æ‰©å±•æ•°å­¦å€¼xåˆ°æ•°å­—(Number)çš„è½¬æ¢
2. `â„¤(x)`ï¼šä»æ•´æ•°xåˆ°BigIntçš„è½¬æ¢
3. `â„(x)`ï¼šä»æ•°å­—æˆ–BigIntåˆ°æ•°å­¦å€¼çš„è½¬æ¢


<Note>
  æ³¨æ„
  - +0Få’Œ-0Fçš„æ•°å­¦å€¼æ˜¯æ•°å­¦å€¼0ã€‚
  - éæœ‰é™å€¼çš„æ•°å­¦å€¼æ²¡æœ‰å®šä¹‰ã€‚
  - xçš„æ‰©å±•æ•°å­¦å€¼æ˜¯æœ‰é™å€¼xçš„æ•°å­¦å€¼ï¼Œåˆ†åˆ«ä¸º+âˆFå’Œ-âˆFçš„+âˆå’Œ-âˆï¼›å®ƒæ²¡æœ‰ä¸ºNaNå®šä¹‰ã€‚
</Note>

<Blockquote>
1. If x is NaN or y is NaN, return NaN.
2. If x is +âˆğ”½ and y is -âˆğ”½, return NaN.
3. If x is -âˆğ”½ and y is +âˆğ”½, return NaN.
4. If x is either +âˆğ”½ or -âˆğ”½, return x.
5. If y is either +âˆğ”½ or -âˆğ”½, return y.
6. Assert: x and y are both finite.
7. If x is -0ğ”½ and y is -0ğ”½, return -0ğ”½.
8. Return ğ”½(â„(x) + â„(y)).
</Blockquote>

```ts
export function add(x: number, y: number): number {
  // If x is NaN or y is NaN, return NaN.
  if(isNaN(x) || isNaN(y)) return NaN;
  // If x is +âˆğ”½ and y is -âˆğ”½, return NaN.
  // If x is -âˆğ”½ and y is +âˆğ”½, return NaN.
  if(x === Infinity && y === -Infinity || x === -Infinity && y === Infinity) return NaN;

  // If x is either +âˆğ”½ or -âˆğ”½, return x.
  if(x === Infinity || x === -Infinity) return x;
  // If y is either +âˆğ”½ or -âˆğ”½, return y.
  if(y === Infinity || y === -Infinity) return y;

  // Assert: x and y are both finite.
  if(!isFinite(x) || !isFinite(y)) {
    throw new Error('Assertion failed: x and y must be finite.')
  }
  // If x is -0ğ”½ and y is -0ğ”½, return -0ğ”½.
  if(isNegativeZero(x as ESZeroType) && isNegativeZero(y as ESZeroType)) return -0;
  // Otherwise, return x + y.
  return x + y
}
```

### subtract

æŠ½è±¡è¿ç®—`suttract`æ¥å—å‚æ•°`x`ï¼ˆä¸€ä¸ªNumberï¼‰å’Œ`y`ï¼ˆä¸€ä¸ªNumberï¼‰å¹¶è¿”å›ä¸€ä¸ª`Number`ã€‚

å®ƒæ‰§è¡Œå‡æ³•ï¼Œäº§ç”Ÿå…¶æ“ä½œæ•°çš„å·®å¼‚ï¼›
xæ˜¯**minuend**ï¼Œyæ˜¯**subtrahend**ã€‚è°ƒç”¨æ—¶ï¼Œå®ƒä¼šæ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

```md
1. Return add(x, unaryMinus(y))
```

### equal

æŠ½è±¡æ“ä½œ `equal` æ¥å—å‚æ•°`x(Number)`å’Œ`y(Number)`ï¼Œå¹¶è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ã€‚è°ƒç”¨æ—¶ï¼Œå®ƒä¼šæ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

<Blockquote>
1. If x is NaN, return false.
2. If y is NaN, return false.
3. If x is y, return true.
4. If x is +0ğ”½ and y is -0ğ”½, return true.
5. If x is -0ğ”½ and y is +0ğ”½, return true.
6. Return false.
</Blockquote>


é™¤äº†`NaN`, å…¶ä»–ç±»å‹çš„å€¼éƒ½æ˜¯é›¶å€¼æ¯”è¾ƒ

```ts
export function equal(x: number, y: number): boolean {
  // for special NaN values
  if(x !== x || y !== y) return false;
  return x === y
}
```

### multiply

æŠ½è±¡æ“ä½œ `multiply` æ¥å—å‚æ•°`x(Number)`å’Œ`y(Number)`ï¼Œå¹¶è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ã€‚

è°ƒç”¨æ—¶ï¼Œå®ƒæ ¹æ®[IEEE 754-2019](https://tc39.es/ecma262/#sec-bibliography)äºŒè¿›åˆ¶åŒç²¾åº¦ç®—æœ¯çš„è§„åˆ™æ‰§è¡Œä¹˜æ³•ï¼Œäº§ç”Ÿ`x`å’Œ`y`çš„ä¹˜ç§¯ã€‚
è°ƒç”¨æ—¶ï¼Œå®ƒä¼šæ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

<Blockquote>

1. If x is NaN or y is NaN, return NaN.
2. If x is either +âˆğ”½ or -âˆğ”½, then
  a. If y is either +0ğ”½ or -0ğ”½, return NaN.
  b. If y > +0ğ”½, return x.
  c. Return -x.
3. If y is either +âˆğ”½ or -âˆğ”½, then
  a. If x is either +0ğ”½ or -0ğ”½, return NaN.
  b. If x > +0ğ”½, return y.
  c. Return -y.
4. If x is -0ğ”½, then
  a. If y is -0ğ”½ or y < -0ğ”½, return +0ğ”½.
  b. Else, return -0ğ”½.
5. If y is -0ğ”½, then
  a. If x < -0ğ”½, return +0ğ”½.
  b. Else, return -0ğ”½.
6. Return ğ”½(â„(x) Ã— â„(y)).
</Blockquote>


```ts
export function multiply(x: number, y: number): boolean {
  if(isNaN(x) && isNaN(y)) return NaN;

  if(x === -Infinity || x === Infinity) {
    if(isNegativeZero(y as ESZeroType) || !isNegativeZero(y as ESZeroType)) return NaN;
    if(y > 0) return x;
    return -x
  }

  if(y === -Infinity || y === Infinity) {
    if(isNegativeZero(x as ESZeroType) || !isNegativeZero(x as ESZeroType)) return NaN;
    if(x > 0) return y;
    return -y
  }

  if(isNegativeZero(x as ESZeroType)) {
    if(isNegativeZero(y as ESZeroType) || y < 0) return 0;
    return -0
  }

  if(isNegativeZero(y as ESZeroType)) {
    if(isNegativeZero(x as ESZeroType) || x < 0) return 0;
    return -0
  }
  return x * y
}
```

### divide

æŠ½è±¡æ“ä½œ `divide` æ¥å—å‚æ•°`x(Number)`å’Œ`y(Number)`ï¼Œå¹¶è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ã€‚

è°ƒç”¨æ—¶ï¼Œå®ƒæ ¹æ®[IEEE 754-2019](https://tc39.es/ecma262/#sec-bibliography)äºŒè¿›åˆ¶åŒç²¾åº¦ç®—æœ¯çš„è§„åˆ™æ‰§è¡Œé™¤æ³•æ³•ï¼Œäº§ç”Ÿ`x`å’Œ`y`çš„å•†ã€‚
è°ƒç”¨æ—¶ï¼Œå®ƒä¼šæ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

<Blockquote>

1. If x is NaN or y is NaN, return NaN.
2. If x is either +âˆğ”½ or -âˆğ”½, then
  a. If y is either +âˆğ”½ or -âˆğ”½, return NaN.
  b. If y is +0ğ”½ or y > +0ğ”½, return x.
  c. Return -x.
3. If y is +âˆğ”½, then
  a. If x is +0ğ”½ or x > +0ğ”½, return +0ğ”½. Otherwise, return -0ğ”½.
4. If y is -âˆğ”½, then
  a. If x is +0ğ”½ or x > +0ğ”½, return -0ğ”½. Otherwise, return +0ğ”½.
5. If x is either +0ğ”½ or -0ğ”½, then
  a. If y is either +0ğ”½ or -0ğ”½, return NaN.
  b. If y > +0ğ”½, return x.
  c. Return -x.
6. If y is +0ğ”½, then
  a. If x > +0ğ”½, return +âˆğ”½. Otherwise, return -âˆğ”½.
7. If y is -0ğ”½, then
  a. If x > +0ğ”½, return -âˆğ”½. Otherwise, return +âˆğ”½.
8. Return ğ”½(â„(x) / â„(y)).
</Blockquote>


```ts
export function divide(x: number, y: number): number {

  // 1. If x is NaN or y is NaN, return NaN.
  if(isNaN(x) && isNaN(y)) return NaN;

  if(x === -Infinity || x === Infinity) {
    if(y === -Infinity || y === Infinity) return NaN;
    if(y >= 0) return x;
    return -x
  }

  if(y === -Infinity) {
    if(!isNegativeZero(x as ESZeroType) || x > +0) return -0;
    return +0
  }

  if(y === Infinity) {
    if(!isNegativeZero(x as ESZeroType) || x > +0) return +0;
    return -0
  }

  if(isNegativeZero(x as ESZeroType) || !isNegativeZero(x as ESZeroType)) {
    if(isNegativeZero(y as ESZeroType) || !isNegativeZero(y as ESZeroType)) return NaN;
    if(y > +0) return x;
    return -x
  }

  // 1/0
  // -1/0
  if(!isNegativeZero(y as ESZeroType)) {
    if(x > 0) return +Infinity
    return -Infinity
  }

  // 1/-0
  // -1/-0
  if(isNegativeZero(y as ESZeroType)) {
    if(x > 0) return -Infinity
    return +Infinity
  }

  return x / y;
}
```

### reminder

æŠ½è±¡æ“ä½œ`remainder`æ¥å—å‚æ•°`n`å’Œ`d`ï¼ˆä¸€ä¸ªæ•°å­—ï¼‰å¹¶è¿”å›ä¸€ä¸ªæ•°å­—ã€‚å®ƒä»å…¶æ“ä½œæ•°çš„éšå«é™¤æ³•ä¸­äº§ç”Ÿä½™æ•°ï¼Œå…¶ä¸­næ˜¯é™¤æ•°ï¼Œdæ˜¯é™¤æ•°ã€‚
è°ƒç”¨æ—¶ï¼Œå®ƒä¼šæ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

<Blockquote>

1. If n is NaN or d is NaN, return NaN.
2. If n is either +âˆğ”½ or -âˆğ”½, return NaN.
3. If d is either +âˆğ”½ or -âˆğ”½, return n.
4. If d is either +0ğ”½ or -0ğ”½, return NaN.
5. If n is either +0ğ”½ or -0ğ”½, return n.
6. Assert: n and d are finite and non-zero.
7. Let quotient be â„(n) / â„(d).
8. Let q be truncate(quotient).
9. Let r be â„(n) - (â„(d) Ã— q).
10. If r = 0 and n < -0ğ”½, return -0ğ”½.
11. Return ğ”½(r).
</Blockquote>


```ts
export function reminder(n: number, d: number): number {

  // 1. If n is NaN or d is NaN, return NaN.
  if(isNaN(n) || isNaN(d)) return NaN;

  if(n === Infinity || n === -Infinity) return NaN;

  if(d === Infinity || d === -Infinity) return n;

  if(isNegativeZero(d as ESZeroType) || !isNegativeZero(d as ESZeroType)) return NaN;

  if(isNegativeZero(n as ESZeroType) || !isNegativeZero(n as ESZeroType)) return n;

  if(n === 0 || d === 0 || !isFinite(d) || !isFinite(n)) {
    throw new Error('Assertion failed: n and d must be finite.')
  }

  let quotient = n / d;

  // æ•°å­¦å‡½æ•°æˆªæ–­ï¼ˆxï¼‰é€šè¿‡å‘é›¶å››èˆäº”å…¥å»é™¤xçš„åˆ†æ•°éƒ¨åˆ†ï¼Œå¦‚æœx < 0ï¼Œåˆ™äº§ç”Ÿ-floorï¼ˆ-xï¼‰ï¼Œå¦åˆ™äº§ç”Ÿfloorï¼ˆxï¼‰ã€‚
  let q = truncate(quotient);

  let r = n - (d * q);

  if(r === 0 && n < -0) return -0;

  return r;
}

// ç¬¦å·â€œx modulo yâ€ï¼ˆyå¿…é¡»æ˜¯æœ‰é™å’Œéé›¶ï¼‰è®¡ç®—ä¸yï¼ˆæˆ–é›¶ï¼‰ç›¸åŒç¬¦å·çš„å€¼kï¼Œ
// è¿™æ ·å¯¹äºä¸€äº›æ•´æ•°qï¼Œabs(k) < abs(y)å’Œx - k = q Ã— yã€‚
export function modulo(x: number, y: number) {
  // Step 1: Ensure y is finite and non-zero
  if (!Number.isFinite(y) || y === 0) {
    throw new Error("y must be finite and non-zero");
  }

  // Step 2: Calculate the remainder of the division of x by y
  let remainder = x % y;

  // Step 3: Adjust the result based on the sign of y
  if ((y > 0 && remainder < 0) || (y < 0 && remainder > 0)) {
    remainder += y;
  }

  return remainder;
}

export function floor(x: number) {
  return x - modulo(x, 1)
}

// æ•°å­¦å‡½æ•°æˆªæ–­ï¼ˆxï¼‰é€šè¿‡å‘é›¶å››èˆäº”å…¥å»é™¤xçš„åˆ†æ•°éƒ¨åˆ†ï¼Œå¦‚æœx < 0ï¼Œåˆ™äº§ç”Ÿ-floorï¼ˆ-xï¼‰ï¼Œå¦åˆ™äº§ç”Ÿfloorï¼ˆxï¼‰ã€‚
export function truncate(x: number) {
  if(x < 0) return -floor(-x);
  return floor(x);
}

```

### sameValue

æŠ½è±¡æ“ä½œ `sameValue` æ¥å—å‚æ•°`x(Number)`å’Œ`y(Number)`ï¼Œå¹¶è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ã€‚è°ƒç”¨æ—¶ï¼Œå®ƒä¼šæ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

<Blockquote>

1. If x is NaN and y is NaN, return true.
2. If x is +0ğ”½ and y is -0ğ”½, return false.
3. If x is -0ğ”½ and y is +0ğ”½, return false.
4. If x is y, return true.
5. Return false.
</Blockquote>


```ts
// åŒå€¼æ¯”è¾ƒ Object.is åœ¨numberä¸­çš„åº”ç”¨
export function sameValue(x: number, y: number): boolean {

  // x = NaN y = NaN
  if(isNaN(x) && isNaN(y)) return true;

  // x = +0 && y = -0
  // x = -0 && y = +0
  if(
    (!isNegativeZero(x) && isNegativeZero(y)) ||
    (isNegativeZero(x) && !isNegativeZero(y))
  ) return false;

  return x === y
}
```

ä»ä¸Šè¿°çœ‹åˆ°ï¼Œ`Object.is`åœ¨numberä¸­çš„å€¼æ¯”è¾ƒæ˜¯**åŒå€¼æ¯”è¾ƒ**ï¼Œç‰¹æ®Šåœºæ™¯`x==y`éƒ½ç›¸åŒ
ä¸”éƒ½æ˜¯`NaN`çš„æƒ…å†µä¸‹ï¼Œä¹Ÿæ˜¯ç›¸ç­‰çš„ï¼›

**æ³¨æ„ï¼Œè¿™é‡Œæ’é™¤äº†`0`å’Œ`-0`ç›¸åŒçš„æƒ…å†µ**ï¼Œå¦‚æœè¦è®©ä¸¤è€…ç›¸ç­‰ï¼Œä½¿ç”¨é›¶å€¼æ¯”è¾ƒçš„æ–¹æ³•[sameValueZero](/operations/number/sameValueZero)


### sameValueZero

æŠ½è±¡æ“ä½œ `sameValueZero` æ¥å—å‚æ•°`x(Number)`å’Œ`y(Number)`ï¼Œå¹¶è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ã€‚è°ƒç”¨æ—¶ï¼Œå®ƒä¼šæ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

<Blockquote>

1. If x is NaN and y is NaN, return true.
2. If x is +0ğ”½ and y is -0ğ”½, return true.
3. If x is -0ğ”½ and y is +0ğ”½, return true.
4. If x is y, return true.
5. Return false.
</Blockquote>


```ts
// é›¶å€¼æ¯”è¾ƒ
export function sameValueZero(x: number, y: number): boolean {
  // (x !== x && y !== y) like isNaN(x) isNaN(y)
  return x === y || (x !== x && y !== y)
}
```