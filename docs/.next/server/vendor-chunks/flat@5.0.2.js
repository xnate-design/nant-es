"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/flat@5.0.2";
exports.ids = ["vendor-chunks/flat@5.0.2"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/flat@5.0.2/node_modules/flat/index.js":
/*!*******************************************************************!*\
  !*** ../node_modules/.pnpm/flat@5.0.2/node_modules/flat/index.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = flatten;\nflatten.flatten = flatten;\nflatten.unflatten = unflatten;\nfunction isBuffer(obj) {\n    return obj && obj.constructor && typeof obj.constructor.isBuffer === \"function\" && obj.constructor.isBuffer(obj);\n}\nfunction keyIdentity(key) {\n    return key;\n}\nfunction flatten(target, opts) {\n    opts = opts || {};\n    const delimiter = opts.delimiter || \".\";\n    const maxDepth = opts.maxDepth;\n    const transformKey = opts.transformKey || keyIdentity;\n    const output = {};\n    function step(object, prev, currentDepth) {\n        currentDepth = currentDepth || 1;\n        Object.keys(object).forEach(function(key) {\n            const value = object[key];\n            const isarray = opts.safe && Array.isArray(value);\n            const type = Object.prototype.toString.call(value);\n            const isbuffer = isBuffer(value);\n            const isobject = type === \"[object Object]\" || type === \"[object Array]\";\n            const newKey = prev ? prev + delimiter + transformKey(key) : transformKey(key);\n            if (!isarray && !isbuffer && isobject && Object.keys(value).length && (!opts.maxDepth || currentDepth < maxDepth)) {\n                return step(value, newKey, currentDepth + 1);\n            }\n            output[newKey] = value;\n        });\n    }\n    step(target);\n    return output;\n}\nfunction unflatten(target, opts) {\n    opts = opts || {};\n    const delimiter = opts.delimiter || \".\";\n    const overwrite = opts.overwrite || false;\n    const transformKey = opts.transformKey || keyIdentity;\n    const result = {};\n    const isbuffer = isBuffer(target);\n    if (isbuffer || Object.prototype.toString.call(target) !== \"[object Object]\") {\n        return target;\n    }\n    // safely ensure that the key is\n    // an integer.\n    function getkey(key) {\n        const parsedKey = Number(key);\n        return isNaN(parsedKey) || key.indexOf(\".\") !== -1 || opts.object ? key : parsedKey;\n    }\n    function addKeys(keyPrefix, recipient, target) {\n        return Object.keys(target).reduce(function(result, key) {\n            result[keyPrefix + delimiter + key] = target[key];\n            return result;\n        }, recipient);\n    }\n    function isEmpty(val) {\n        const type = Object.prototype.toString.call(val);\n        const isArray = type === \"[object Array]\";\n        const isObject = type === \"[object Object]\";\n        if (!val) {\n            return true;\n        } else if (isArray) {\n            return !val.length;\n        } else if (isObject) {\n            return !Object.keys(val).length;\n        }\n    }\n    target = Object.keys(target).reduce(function(result, key) {\n        const type = Object.prototype.toString.call(target[key]);\n        const isObject = type === \"[object Object]\" || type === \"[object Array]\";\n        if (!isObject || isEmpty(target[key])) {\n            result[key] = target[key];\n            return result;\n        } else {\n            return addKeys(key, result, flatten(target[key], opts));\n        }\n    }, {});\n    Object.keys(target).forEach(function(key) {\n        const split = key.split(delimiter).map(transformKey);\n        let key1 = getkey(split.shift());\n        let key2 = getkey(split[0]);\n        let recipient = result;\n        while(key2 !== undefined){\n            if (key1 === \"__proto__\") {\n                return;\n            }\n            const type = Object.prototype.toString.call(recipient[key1]);\n            const isobject = type === \"[object Object]\" || type === \"[object Array]\";\n            // do not write over falsey, non-undefined values if overwrite is false\n            if (!overwrite && !isobject && typeof recipient[key1] !== \"undefined\") {\n                return;\n            }\n            if (overwrite && !isobject || !overwrite && recipient[key1] == null) {\n                recipient[key1] = typeof key2 === \"number\" && !opts.object ? [] : {};\n            }\n            recipient = recipient[key1];\n            if (split.length > 0) {\n                key1 = getkey(split.shift());\n                key2 = getkey(split[0]);\n            }\n        }\n        // unflatten again for 'messy objects'\n        recipient[key1] = unflatten(target[key], opts);\n    });\n    return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZsYXRANS4wLjIvbm9kZV9tb2R1bGVzL2ZsYXQvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUFBQSxPQUFPQyxPQUFPLEdBQUdDO0FBQ2pCQSxRQUFRQSxPQUFPLEdBQUdBO0FBQ2xCQSxRQUFRQyxTQUFTLEdBQUdBO0FBRXBCLFNBQVNDLFNBQVVDLEdBQUc7SUFDcEIsT0FBT0EsT0FDTEEsSUFBSUMsV0FBVyxJQUNkLE9BQU9ELElBQUlDLFdBQVcsQ0FBQ0YsUUFBUSxLQUFLLGNBQ3JDQyxJQUFJQyxXQUFXLENBQUNGLFFBQVEsQ0FBQ0M7QUFDN0I7QUFFQSxTQUFTRSxZQUFhQyxHQUFHO0lBQ3ZCLE9BQU9BO0FBQ1Q7QUFFQSxTQUFTTixRQUFTTyxNQUFNLEVBQUVDLElBQUk7SUFDNUJBLE9BQU9BLFFBQVEsQ0FBQztJQUVoQixNQUFNQyxZQUFZRCxLQUFLQyxTQUFTLElBQUk7SUFDcEMsTUFBTUMsV0FBV0YsS0FBS0UsUUFBUTtJQUM5QixNQUFNQyxlQUFlSCxLQUFLRyxZQUFZLElBQUlOO0lBQzFDLE1BQU1PLFNBQVMsQ0FBQztJQUVoQixTQUFTQyxLQUFNQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsWUFBWTtRQUN2Q0EsZUFBZUEsZ0JBQWdCO1FBQy9CQyxPQUFPQyxJQUFJLENBQUNKLFFBQVFLLE9BQU8sQ0FBQyxTQUFVYixHQUFHO1lBQ3ZDLE1BQU1jLFFBQVFOLE1BQU0sQ0FBQ1IsSUFBSTtZQUN6QixNQUFNZSxVQUFVYixLQUFLYyxJQUFJLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0o7WUFDM0MsTUFBTUssT0FBT1IsT0FBT1MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ1I7WUFDNUMsTUFBTVMsV0FBVzNCLFNBQVNrQjtZQUMxQixNQUFNVSxXQUNKTCxTQUFTLHFCQUNUQSxTQUFTO1lBR1gsTUFBTU0sU0FBU2hCLE9BQ1hBLE9BQU9OLFlBQVlFLGFBQWFMLE9BQ2hDSyxhQUFhTDtZQUVqQixJ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QVMsYUFBYTtnQkFDeEI7WUFDRjtZQUVBLE1BQU14QixPQUFPUixPQUFPUyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDYyxTQUFTLENBQUNPLEtBQUs7WUFDM0QsTUFBTW5CLFdBQ0pMLFNBQVMscUJBQ1RBLFNBQVM7WUFHWCx1RUFBdUU7WUFDdkUsSUFBSSxDQUFDUSxhQUFhLENBQUNILFlBQVksT0FBT1ksU0FBUyxDQUFDTyxLQUFLLEtBQUssYUFBYTtnQkFDckU7WUFDRjtZQUVBLElBQUksYUFBYyxDQUFDbkIsWUFBYyxDQUFDRyxhQUFhUyxTQUFTLENBQUNPLEtBQUssSUFBSSxNQUFPO2dCQUN2RVAsU0FBUyxDQUFDTyxLQUFLLEdBQ2IsT0FBT0UsU0FBUyxZQUNoQixDQUFDM0MsS0FBS00sTUFBTSxHQUFHLEVBQUUsR0FBRyxDQUFDO1lBRXpCO1lBRUE0QixZQUFZQSxTQUFTLENBQUNPLEtBQUs7WUFDM0IsSUFBSUYsTUFBTWYsTUFBTSxHQUFHLEdBQUc7Z0JBQ3BCaUIsT0FBT2QsT0FBT1ksTUFBTUcsS0FBSztnQkFDekJDLE9BQU9oQixPQUFPWSxLQUFLLENBQUMsRUFBRTtZQUN4QjtRQUNGO1FBRUEsc0NBQXNDO1FBQ3RDTCxTQUFTLENBQUNPLEtBQUssR0FBR2hELFVBQVVNLE1BQU0sQ0FBQ0QsSUFBSSxFQUFFRTtJQUMzQztJQUVBLE9BQU8wQjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtZG9jcy8uLi9ub2RlX21vZHVsZXMvLnBucG0vZmxhdEA1LjAuMi9ub2RlX21vZHVsZXMvZmxhdC9pbmRleC5qcz8zOGE4Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZmxhdHRlblxuZmxhdHRlbi5mbGF0dGVuID0gZmxhdHRlblxuZmxhdHRlbi51bmZsYXR0ZW4gPSB1bmZsYXR0ZW5cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gb2JqICYmXG4gICAgb2JqLmNvbnN0cnVjdG9yICYmXG4gICAgKHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicpICYmXG4gICAgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuZnVuY3Rpb24ga2V5SWRlbnRpdHkgKGtleSkge1xuICByZXR1cm4ga2V5XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW4gKHRhcmdldCwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gIGNvbnN0IGRlbGltaXRlciA9IG9wdHMuZGVsaW1pdGVyIHx8ICcuJ1xuICBjb25zdCBtYXhEZXB0aCA9IG9wdHMubWF4RGVwdGhcbiAgY29uc3QgdHJhbnNmb3JtS2V5ID0gb3B0cy50cmFuc2Zvcm1LZXkgfHwga2V5SWRlbnRpdHlcbiAgY29uc3Qgb3V0cHV0ID0ge31cblxuICBmdW5jdGlvbiBzdGVwIChvYmplY3QsIHByZXYsIGN1cnJlbnREZXB0aCkge1xuICAgIGN1cnJlbnREZXB0aCA9IGN1cnJlbnREZXB0aCB8fCAxXG4gICAgT2JqZWN0LmtleXMob2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV1cbiAgICAgIGNvbnN0IGlzYXJyYXkgPSBvcHRzLnNhZmUgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSlcbiAgICAgIGNvbnN0IHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpXG4gICAgICBjb25zdCBpc2J1ZmZlciA9IGlzQnVmZmVyKHZhbHVlKVxuICAgICAgY29uc3QgaXNvYmplY3QgPSAoXG4gICAgICAgIHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nIHx8XG4gICAgICAgIHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICAgIClcblxuICAgICAgY29uc3QgbmV3S2V5ID0gcHJldlxuICAgICAgICA/IHByZXYgKyBkZWxpbWl0ZXIgKyB0cmFuc2Zvcm1LZXkoa2V5KVxuICAgICAgICA6IHRyYW5zZm9ybUtleShrZXkpXG5cbiAgICAgIGlmICghaXNhcnJheSAmJiAhaXNidWZmZXIgJiYgaXNvYmplY3QgJiYgT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCAmJlxuICAgICAgICAoIW9wdHMubWF4RGVwdGggfHwgY3VycmVudERlcHRoIDwgbWF4RGVwdGgpKSB7XG4gICAgICAgIHJldHVybiBzdGVwKHZhbHVlLCBuZXdLZXksIGN1cnJlbnREZXB0aCArIDEpXG4gICAgICB9XG5cbiAgICAgIG91dHB1dFtuZXdLZXldID0gdmFsdWVcbiAgICB9KVxuICB9XG5cbiAgc3RlcCh0YXJnZXQpXG5cbiAgcmV0dXJuIG91dHB1dFxufVxuXG5mdW5jdGlvbiB1bmZsYXR0ZW4gKHRhcmdldCwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gIGNvbnN0IGRlbGltaXRlciA9IG9wdHMuZGVsaW1pdGVyIHx8ICcuJ1xuICBjb25zdCBvdmVyd3JpdGUgPSBvcHRzLm92ZXJ3cml0ZSB8fCBmYWxzZVxuICBjb25zdCB0cmFuc2Zvcm1LZXkgPSBvcHRzLnRyYW5zZm9ybUtleSB8fCBrZXlJZGVudGl0eVxuICBjb25zdCByZXN1bHQgPSB7fVxuXG4gIGNvbnN0IGlzYnVmZmVyID0gaXNCdWZmZXIodGFyZ2V0KVxuICBpZiAoaXNidWZmZXIgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRhcmdldCkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgcmV0dXJuIHRhcmdldFxuICB9XG5cbiAgLy8gc2FmZWx5IGVuc3VyZSB0aGF0IHRoZSBrZXkgaXNcbiAgLy8gYW4gaW50ZWdlci5cbiAgZnVuY3Rpb24gZ2V0a2V5IChrZXkpIHtcbiAgICBjb25zdCBwYXJzZWRLZXkgPSBOdW1iZXIoa2V5KVxuXG4gICAgcmV0dXJuIChcbiAgICAgIGlzTmFOKHBhcnNlZEtleSkgfHxcbiAgICAgIGtleS5pbmRleE9mKCcuJykgIT09IC0xIHx8XG4gICAgICBvcHRzLm9iamVjdFxuICAgICkgPyBrZXlcbiAgICAgIDogcGFyc2VkS2V5XG4gIH1cblxuICBmdW5jdGlvbiBhZGRLZXlzIChrZXlQcmVmaXgsIHJlY2lwaWVudCwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldCkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGtleSkge1xuICAgICAgcmVzdWx0W2tleVByZWZpeCArIGRlbGltaXRlciArIGtleV0gPSB0YXJnZXRba2V5XVxuXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSwgcmVjaXBpZW50KVxuICB9XG5cbiAgZnVuY3Rpb24gaXNFbXB0eSAodmFsKSB7XG4gICAgY29uc3QgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpXG4gICAgY29uc3QgaXNBcnJheSA9IHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICBjb25zdCBpc09iamVjdCA9IHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nXG5cbiAgICBpZiAoIXZhbCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkpIHtcbiAgICAgIHJldHVybiAhdmFsLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHJldHVybiAhT2JqZWN0LmtleXModmFsKS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB0YXJnZXQgPSBPYmplY3Qua2V5cyh0YXJnZXQpLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBrZXkpIHtcbiAgICBjb25zdCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRhcmdldFtrZXldKVxuICAgIGNvbnN0IGlzT2JqZWN0ID0gKHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpXG4gICAgaWYgKCFpc09iamVjdCB8fCBpc0VtcHR5KHRhcmdldFtrZXldKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB0YXJnZXRba2V5XVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWRkS2V5cyhcbiAgICAgICAga2V5LFxuICAgICAgICByZXN1bHQsXG4gICAgICAgIGZsYXR0ZW4odGFyZ2V0W2tleV0sIG9wdHMpXG4gICAgICApXG4gICAgfVxuICB9LCB7fSlcblxuICBPYmplY3Qua2V5cyh0YXJnZXQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGNvbnN0IHNwbGl0ID0ga2V5LnNwbGl0KGRlbGltaXRlcikubWFwKHRyYW5zZm9ybUtleSlcbiAgICBsZXQga2V5MSA9IGdldGtleShzcGxpdC5zaGlmdCgpKVxuICAgIGxldCBrZXkyID0gZ2V0a2V5KHNwbGl0WzBdKVxuICAgIGxldCByZWNpcGllbnQgPSByZXN1bHRcblxuICAgIHdoaWxlIChrZXkyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChrZXkxID09PSAnX19wcm90b19fJykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZWNpcGllbnRba2V5MV0pXG4gICAgICBjb25zdCBpc29iamVjdCA9IChcbiAgICAgICAgdHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgfHxcbiAgICAgICAgdHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgICAgKVxuXG4gICAgICAvLyBkbyBub3Qgd3JpdGUgb3ZlciBmYWxzZXksIG5vbi11bmRlZmluZWQgdmFsdWVzIGlmIG92ZXJ3cml0ZSBpcyBmYWxzZVxuICAgICAgaWYgKCFvdmVyd3JpdGUgJiYgIWlzb2JqZWN0ICYmIHR5cGVvZiByZWNpcGllbnRba2V5MV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoKG92ZXJ3cml0ZSAmJiAhaXNvYmplY3QpIHx8ICghb3ZlcndyaXRlICYmIHJlY2lwaWVudFtrZXkxXSA9PSBudWxsKSkge1xuICAgICAgICByZWNpcGllbnRba2V5MV0gPSAoXG4gICAgICAgICAgdHlwZW9mIGtleTIgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgIW9wdHMub2JqZWN0ID8gW10gOiB7fVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHJlY2lwaWVudCA9IHJlY2lwaWVudFtrZXkxXVxuICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAga2V5MSA9IGdldGtleShzcGxpdC5zaGlmdCgpKVxuICAgICAgICBrZXkyID0gZ2V0a2V5KHNwbGl0WzBdKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHVuZmxhdHRlbiBhZ2FpbiBmb3IgJ21lc3N5IG9iamVjdHMnXG4gICAgcmVjaXBpZW50W2tleTFdID0gdW5mbGF0dGVuKHRhcmdldFtrZXldLCBvcHRzKVxuICB9KVxuXG4gIHJldHVybiByZXN1bHRcbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiZmxhdHRlbiIsInVuZmxhdHRlbiIsImlzQnVmZmVyIiwib2JqIiwiY29uc3RydWN0b3IiLCJrZXlJZGVudGl0eSIsImtleSIsInRhcmdldCIsIm9wdHMiLCJkZWxpbWl0ZXIiLCJtYXhEZXB0aCIsInRyYW5zZm9ybUtleSIsIm91dHB1dCIsInN0ZXAiLCJvYmplY3QiLCJwcmV2IiwiY3VycmVudERlcHRoIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJ2YWx1ZSIsImlzYXJyYXkiLCJzYWZlIiwiQXJyYXkiLCJpc0FycmF5IiwidHlwZSIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImlzYnVmZmVyIiwiaXNvYmplY3QiLCJuZXdLZXkiLCJsZW5ndGgiLCJvdmVyd3JpdGUiLCJyZXN1bHQiLCJnZXRrZXkiLCJwYXJzZWRLZXkiLCJOdW1iZXIiLCJpc05hTiIsImluZGV4T2YiLCJhZGRLZXlzIiwia2V5UHJlZml4IiwicmVjaXBpZW50IiwicmVkdWNlIiwiaXNFbXB0eSIsInZhbCIsImlzT2JqZWN0Iiwic3BsaXQiLCJtYXAiLCJrZXkxIiwic2hpZnQiLCJrZXkyIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/flat@5.0.2/node_modules/flat/index.js\n");

/***/ })

};
;