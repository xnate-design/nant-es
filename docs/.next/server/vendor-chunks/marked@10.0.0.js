"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/marked@10.0.0";
exports.ids = ["vendor-chunks/marked@10.0.0"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/marked@10.0.0/node_modules/marked/lib/marked.esm.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/.pnpm/marked@10.0.0/node_modules/marked/lib/marked.esm.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hooks: () => (/* binding */ _Hooks),\n/* harmony export */   Lexer: () => (/* binding */ _Lexer),\n/* harmony export */   Marked: () => (/* binding */ Marked),\n/* harmony export */   Parser: () => (/* binding */ _Parser),\n/* harmony export */   Renderer: () => (/* binding */ _Renderer),\n/* harmony export */   TextRenderer: () => (/* binding */ _TextRenderer),\n/* harmony export */   Tokenizer: () => (/* binding */ _Tokenizer),\n/* harmony export */   defaults: () => (/* binding */ _defaults),\n/* harmony export */   getDefaults: () => (/* binding */ _getDefaults),\n/* harmony export */   lexer: () => (/* binding */ lexer),\n/* harmony export */   marked: () => (/* binding */ marked),\n/* harmony export */   options: () => (/* binding */ options),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseInline: () => (/* binding */ parseInline),\n/* harmony export */   parser: () => (/* binding */ parser),\n/* harmony export */   setOptions: () => (/* binding */ setOptions),\n/* harmony export */   use: () => (/* binding */ use),\n/* harmony export */   walkTokens: () => (/* binding */ walkTokens)\n/* harmony export */ });\n/**\n * marked v10.0.0 - a markdown parser\n * Copyright (c) 2011-2023, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */ /**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */ /**\n * Gets the original marked default options.\n */ function _getDefaults() {\n    return {\n        async: false,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        hooks: null,\n        pedantic: false,\n        renderer: null,\n        silent: false,\n        tokenizer: null,\n        walkTokens: null\n    };\n}\nlet _defaults = _getDefaults();\nfunction changeDefaults(newDefaults) {\n    _defaults = newDefaults;\n}\n/**\n * Helpers\n */ const escapeTest = /[&<>\"']/;\nconst escapeReplace = new RegExp(escapeTest.source, \"g\");\nconst escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\nconst escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, \"g\");\nconst escapeReplacements = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\"\n};\nconst getEscapeReplacement = (ch)=>escapeReplacements[ch];\nfunction escape(html, encode) {\n    if (encode) {\n        if (escapeTest.test(html)) {\n            return html.replace(escapeReplace, getEscapeReplacement);\n        }\n    } else {\n        if (escapeTestNoEncode.test(html)) {\n            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n    return html;\n}\nconst unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\nfunction unescape(html) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(unescapeTest, (_, n)=>{\n        n = n.toLowerCase();\n        if (n === \"colon\") return \":\";\n        if (n.charAt(0) === \"#\") {\n            return n.charAt(1) === \"x\" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n        }\n        return \"\";\n    });\n}\nconst caret = /(^|[^\\[])\\^/g;\nfunction edit(regex, opt) {\n    regex = typeof regex === \"string\" ? regex : regex.source;\n    opt = opt || \"\";\n    const obj = {\n        replace: (name, val)=>{\n            val = typeof val === \"object\" && \"source\" in val ? val.source : val;\n            val = val.replace(caret, \"$1\");\n            regex = regex.replace(name, val);\n            return obj;\n        },\n        getRegex: ()=>{\n            return new RegExp(regex, opt);\n        }\n    };\n    return obj;\n}\nfunction cleanUrl(href) {\n    try {\n        href = encodeURI(href).replace(/%25/g, \"%\");\n    } catch (e) {\n        return null;\n    }\n    return href;\n}\nconst noopTest = {\n    exec: ()=>null\n};\nfunction splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    const row = tableRow.replace(/\\|/g, (match, offset, str)=>{\n        let escaped = false;\n        let curr = offset;\n        while(--curr >= 0 && str[curr] === \"\\\\\")escaped = !escaped;\n        if (escaped) {\n            // odd number of slashes means | is escaped\n            // so we leave it alone\n            return \"|\";\n        } else {\n            // add space before unescaped |\n            return \" |\";\n        }\n    }), cells = row.split(/ \\|/);\n    let i = 0;\n    // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n        cells.pop();\n    }\n    if (count) {\n        if (cells.length > count) {\n            cells.splice(count);\n        } else {\n            while(cells.length < count)cells.push(\"\");\n        }\n    }\n    for(; i < cells.length; i++){\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(/\\\\\\|/g, \"|\");\n    }\n    return cells;\n}\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */ function rtrim(str, c, invert) {\n    const l = str.length;\n    if (l === 0) {\n        return \"\";\n    }\n    // Length of suffix matching the invert condition.\n    let suffLen = 0;\n    // Step left until we fail to match the invert condition.\n    while(suffLen < l){\n        const currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && !invert) {\n            suffLen++;\n        } else if (currChar !== c && invert) {\n            suffLen++;\n        } else {\n            break;\n        }\n    }\n    return str.slice(0, l - suffLen);\n}\nfunction findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n    let level = 0;\n    for(let i = 0; i < str.length; i++){\n        if (str[i] === \"\\\\\") {\n            i++;\n        } else if (str[i] === b[0]) {\n            level++;\n        } else if (str[i] === b[1]) {\n            level--;\n            if (level < 0) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\nfunction outputLink(cap, link, raw, lexer) {\n    const href = link.href;\n    const title = link.title ? escape(link.title) : null;\n    const text = cap[1].replace(/\\\\([\\[\\]])/g, \"$1\");\n    if (cap[0].charAt(0) !== \"!\") {\n        lexer.state.inLink = true;\n        const token = {\n            type: \"link\",\n            raw,\n            href,\n            title,\n            text,\n            tokens: lexer.inlineTokens(text)\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    return {\n        type: \"image\",\n        raw,\n        href,\n        title,\n        text: escape(text)\n    };\n}\nfunction indentCodeCompensation(raw, text) {\n    const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n    if (matchIndentToCode === null) {\n        return text;\n    }\n    const indentToCode = matchIndentToCode[1];\n    return text.split(\"\\n\").map((node)=>{\n        const matchIndentInNode = node.match(/^\\s+/);\n        if (matchIndentInNode === null) {\n            return node;\n        }\n        const [indentInNode] = matchIndentInNode;\n        if (indentInNode.length >= indentToCode.length) {\n            return node.slice(indentToCode.length);\n        }\n        return node;\n    }).join(\"\\n\");\n}\n/**\n * Tokenizer\n */ class _Tokenizer {\n    constructor(options){\n        this.options = options || _defaults;\n    }\n    space(src) {\n        const cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: \"space\",\n                raw: cap[0]\n            };\n        }\n    }\n    code(src) {\n        const cap = this.rules.block.code.exec(src);\n        if (cap) {\n            const text = cap[0].replace(/^ {1,4}/gm, \"\");\n            return {\n                type: \"code\",\n                raw: cap[0],\n                codeBlockStyle: \"indented\",\n                text: !this.options.pedantic ? rtrim(text, \"\\n\") : text\n            };\n        }\n    }\n    fences(src) {\n        const cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            const raw = cap[0];\n            const text = indentCodeCompensation(raw, cap[3] || \"\");\n            return {\n                type: \"code\",\n                raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, \"$1\") : cap[2],\n                text\n            };\n        }\n    }\n    heading(src) {\n        const cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            let text = cap[2].trim();\n            // remove trailing #s\n            if (/#$/.test(text)) {\n                const trimmed = rtrim(text, \"#\");\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                } else if (!trimmed || / $/.test(trimmed)) {\n                    // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n            }\n            return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[1].length,\n                text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    }\n    hr(src) {\n        const cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: \"hr\",\n                raw: cap[0]\n            };\n        }\n    }\n    blockquote(src) {\n        const cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            const text = rtrim(cap[0].replace(/^ *>[ \\t]?/gm, \"\"), \"\\n\");\n            const top = this.lexer.state.top;\n            this.lexer.state.top = true;\n            const tokens = this.lexer.blockTokens(text);\n            this.lexer.state.top = top;\n            return {\n                type: \"blockquote\",\n                raw: cap[0],\n                tokens,\n                text\n            };\n        }\n    }\n    list(src) {\n        let cap = this.rules.block.list.exec(src);\n        if (cap) {\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n            const list = {\n                type: \"list\",\n                raw: \"\",\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : \"\",\n                loose: false,\n                items: []\n            };\n            bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n            if (this.options.pedantic) {\n                bull = isordered ? bull : \"[*+-]\";\n            }\n            // Get next list item\n            const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n            let raw = \"\";\n            let itemContents = \"\";\n            let endsWithBlankLine = false;\n            // Check if current bullet point can start a new List Item\n            while(src){\n                let endEarly = false;\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n                if (this.rules.block.hr.test(src)) {\n                    break;\n                }\n                raw = cap[0];\n                src = src.substring(raw.length);\n                let line = cap[2].split(\"\\n\", 1)[0].replace(/^\\t+/, (t)=>\" \".repeat(3 * t.length));\n                let nextLine = src.split(\"\\n\", 1)[0];\n                let indent = 0;\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimStart();\n                } else {\n                    indent = cap[2].search(/[^ ]/); // Find first non-space char\n                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n                let blankLine = false;\n                if (!line && /^ *$/.test(nextLine)) {\n                    raw += nextLine + \"\\n\";\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n                if (!endEarly) {\n                    const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n                    const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n                    const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n                    const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n                    // Check if following lines should be included in List Item\n                    while(src){\n                        const rawLine = src.split(\"\\n\", 1)[0];\n                        nextLine = rawLine;\n                        // Re-align to follow commonmark nesting rules\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, \"  \");\n                        }\n                        // End list item if found code fences\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new heading\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new bullet\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n                        // Horizontal rule found\n                        if (hrRegex.test(src)) {\n                            break;\n                        }\n                        if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {\n                            itemContents += \"\\n\" + nextLine.slice(indent);\n                        } else {\n                            // not enough indentation\n                            if (blankLine) {\n                                break;\n                            }\n                            // paragraph continuation unless last line was a different block level element\n                            if (line.search(/[^ ]/) >= 4) {\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n                            itemContents += \"\\n\" + nextLine;\n                        }\n                        if (!blankLine && !nextLine.trim()) {\n                            blankLine = true;\n                        }\n                        raw += rawLine + \"\\n\";\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLine.slice(indent);\n                    }\n                }\n                if (!list.loose) {\n                    // If the previous item ended with a blank line, the list is loose\n                    if (endsWithBlankLine) {\n                        list.loose = true;\n                    } else if (/\\n *\\n *$/.test(raw)) {\n                        endsWithBlankLine = true;\n                    }\n                }\n                let istask = null;\n                let ischecked;\n                // Check for task list items\n                if (this.options.gfm) {\n                    istask = /^\\[[ xX]\\] /.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== \"[ ] \";\n                        itemContents = itemContents.replace(/^\\[[ xX]\\] +/, \"\");\n                    }\n                }\n                list.items.push({\n                    type: \"list_item\",\n                    raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents,\n                    tokens: []\n                });\n                list.raw += raw;\n            }\n            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n            list.items[list.items.length - 1].raw = raw.trimEnd();\n            list.items[list.items.length - 1].text = itemContents.trimEnd();\n            list.raw = list.raw.trimEnd();\n            // Item child tokens handled here at end because we needed to have the final item to trim it first\n            for(let i = 0; i < list.items.length; i++){\n                this.lexer.state.top = false;\n                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                if (!list.loose) {\n                    // Check if list should be loose\n                    const spacers = list.items[i].tokens.filter((t)=>t.type === \"space\");\n                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t)=>/\\n.*\\n/.test(t.raw));\n                    list.loose = hasMultipleLineBreaks;\n                }\n            }\n            // Set all items to loose if list is loose\n            if (list.loose) {\n                for(let i = 0; i < list.items.length; i++){\n                    list.items[i].loose = true;\n                }\n            }\n            return list;\n        }\n    }\n    html(src) {\n        const cap = this.rules.block.html.exec(src);\n        if (cap) {\n            const token = {\n                type: \"html\",\n                block: true,\n                raw: cap[0],\n                pre: cap[1] === \"pre\" || cap[1] === \"script\" || cap[1] === \"style\",\n                text: cap[0]\n            };\n            return token;\n        }\n    }\n    def(src) {\n        const cap = this.rules.block.def.exec(src);\n        if (cap) {\n            const tag = cap[1].toLowerCase().replace(/\\s+/g, \" \");\n            const href = cap[2] ? cap[2].replace(/^<(.*)>$/, \"$1\").replace(this.rules.inline._escapes, \"$1\") : \"\";\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, \"$1\") : cap[3];\n            return {\n                type: \"def\",\n                tag,\n                raw: cap[0],\n                href,\n                title\n            };\n        }\n    }\n    table(src) {\n        const cap = this.rules.block.table.exec(src);\n        if (cap) {\n            if (!/[:|]/.test(cap[2])) {\n                // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n                return;\n            }\n            const item = {\n                type: \"table\",\n                raw: cap[0],\n                header: splitCells(cap[1]).map((c)=>{\n                    return {\n                        text: c,\n                        tokens: []\n                    };\n                }),\n                align: cap[2].replace(/^\\||\\| *$/g, \"\").split(\"|\"),\n                rows: cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, \"\").split(\"\\n\") : []\n            };\n            if (item.header.length === item.align.length) {\n                let l = item.align.length;\n                let i, j, k, row;\n                for(i = 0; i < l; i++){\n                    const align = item.align[i];\n                    if (align) {\n                        if (/^ *-+: *$/.test(align)) {\n                            item.align[i] = \"right\";\n                        } else if (/^ *:-+: *$/.test(align)) {\n                            item.align[i] = \"center\";\n                        } else if (/^ *:-+ *$/.test(align)) {\n                            item.align[i] = \"left\";\n                        } else {\n                            item.align[i] = null;\n                        }\n                    }\n                }\n                l = item.rows.length;\n                for(i = 0; i < l; i++){\n                    item.rows[i] = splitCells(item.rows[i], item.header.length).map((c)=>{\n                        return {\n                            text: c,\n                            tokens: []\n                        };\n                    });\n                }\n                // parse child tokens inside headers and cells\n                // header child tokens\n                l = item.header.length;\n                for(j = 0; j < l; j++){\n                    item.header[j].tokens = this.lexer.inline(item.header[j].text);\n                }\n                // cell child tokens\n                l = item.rows.length;\n                for(j = 0; j < l; j++){\n                    row = item.rows[j];\n                    for(k = 0; k < row.length; k++){\n                        row[k].tokens = this.lexer.inline(row[k].text);\n                    }\n                }\n                return item;\n            }\n        }\n    }\n    lheading(src) {\n        const cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[2].charAt(0) === \"=\" ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1])\n            };\n        }\n    }\n    paragraph(src) {\n        const cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            const text = cap[1].charAt(cap[1].length - 1) === \"\\n\" ? cap[1].slice(0, -1) : cap[1];\n            return {\n                type: \"paragraph\",\n                raw: cap[0],\n                text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    }\n    text(src) {\n        const cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: \"text\",\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0])\n            };\n        }\n    }\n    escape(src) {\n        const cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: \"escape\",\n                raw: cap[0],\n                text: escape(cap[1])\n            };\n        }\n    }\n    tag(src) {\n        const cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            } else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n                this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            } else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = false;\n            }\n            return {\n                type: \"html\",\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                block: false,\n                text: cap[0]\n            };\n        }\n    }\n    link(src) {\n        const cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n                // commonmark requires matching angle brackets\n                if (!/>$/.test(trimmedUrl)) {\n                    return;\n                }\n                // ending angle bracket cannot be escaped\n                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), \"\\\\\");\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            } else {\n                // find closing parenthesis\n                const lastParenIndex = findClosingBracket(cap[2], \"()\");\n                if (lastParenIndex > -1) {\n                    const start = cap[0].indexOf(\"!\") === 0 ? 5 : 4;\n                    const linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = \"\";\n                }\n            }\n            let href = cap[2];\n            let title = \"\";\n            if (this.options.pedantic) {\n                // split pedantic href and title\n                const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n                if (link) {\n                    href = link[1];\n                    title = link[3];\n                }\n            } else {\n                title = cap[3] ? cap[3].slice(1, -1) : \"\";\n            }\n            href = href.trim();\n            if (/^</.test(href)) {\n                if (this.options.pedantic && !/>$/.test(trimmedUrl)) {\n                    // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                } else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline._escapes, \"$1\") : href,\n                title: title ? title.replace(this.rules.inline._escapes, \"$1\") : title\n            }, cap[0], this.lexer);\n        }\n    }\n    reflink(src, links) {\n        let cap;\n        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n            let link = (cap[2] || cap[1]).replace(/\\s+/g, \" \");\n            link = links[link.toLowerCase()];\n            if (!link) {\n                const text = cap[0].charAt(0);\n                return {\n                    type: \"text\",\n                    raw: text,\n                    text\n                };\n            }\n            return outputLink(cap, link, cap[0], this.lexer);\n        }\n    }\n    emStrong(src, maskedSrc, prevChar = \"\") {\n        let match = this.rules.inline.emStrong.lDelim.exec(src);\n        if (!match) return;\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u)) return;\n        const nextChar = match[1] || match[2] || \"\";\n        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n            // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n            const lLength = [\n                ...match[0]\n            ].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            const endReg = match[0][0] === \"*\" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;\n            endReg.lastIndex = 0;\n            // Clip maskedSrc to same section of string as src (move to lexer?)\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while((match = endReg.exec(maskedSrc)) != null){\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                if (!rDelim) continue; // skip single * in __abc*abc__\n                rLength = [\n                    ...rDelim\n                ].length;\n                if (match[3] || match[4]) {\n                    delimTotal += rLength;\n                    continue;\n                } else if (match[5] || match[6]) {\n                    if (lLength % 3 && !((lLength + rLength) % 3)) {\n                        midDelimTotal += rLength;\n                        continue; // CommonMark Emphasis Rules 9-10\n                    }\n                }\n                delimTotal -= rLength;\n                if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n                // Remove extra characters. *a*** -> *a*\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                // char length can be >1 for unicode characters;\n                const lastCharLength = [\n                    ...match[0]\n                ][0].length;\n                const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                // Create `em` if smallest delimiter has odd char count. *a***\n                if (Math.min(lLength, rLength) % 2) {\n                    const text = raw.slice(1, -1);\n                    return {\n                        type: \"em\",\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text)\n                    };\n                }\n                // Create 'strong' if smallest delimiter has even char count. **a***\n                const text = raw.slice(2, -2);\n                return {\n                    type: \"strong\",\n                    raw,\n                    text,\n                    tokens: this.lexer.inlineTokens(text)\n                };\n            }\n        }\n    }\n    codespan(src) {\n        const cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            let text = cap[2].replace(/\\n/g, \" \");\n            const hasNonSpaceChars = /[^ ]/.test(text);\n            const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            text = escape(text, true);\n            return {\n                type: \"codespan\",\n                raw: cap[0],\n                text\n            };\n        }\n    }\n    br(src) {\n        const cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: \"br\",\n                raw: cap[0]\n            };\n        }\n    }\n    del(src) {\n        const cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: \"del\",\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2])\n            };\n        }\n    }\n    autolink(src) {\n        const cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            let text, href;\n            if (cap[2] === \"@\") {\n                text = escape(cap[1]);\n                href = \"mailto:\" + text;\n            } else {\n                text = escape(cap[1]);\n                href = text;\n            }\n            return {\n                type: \"link\",\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: \"text\",\n                        raw: text,\n                        text\n                    }\n                ]\n            };\n        }\n    }\n    url(src) {\n        let cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            let text, href;\n            if (cap[2] === \"@\") {\n                text = escape(cap[0]);\n                href = \"mailto:\" + text;\n            } else {\n                // do extended autolink path validation\n                let prevCapZero;\n                do {\n                    prevCapZero = cap[0];\n                    cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];\n                }while (prevCapZero !== cap[0]);\n                text = escape(cap[0]);\n                if (cap[1] === \"www.\") {\n                    href = \"http://\" + cap[0];\n                } else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: \"link\",\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: \"text\",\n                        raw: text,\n                        text\n                    }\n                ]\n            };\n        }\n    }\n    inlineText(src) {\n        const cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            let text;\n            if (this.lexer.state.inRawBlock) {\n                text = cap[0];\n            } else {\n                text = escape(cap[0]);\n            }\n            return {\n                type: \"text\",\n                raw: cap[0],\n                text\n            };\n        }\n    }\n}\n/**\n * Block-Level Grammar\n */ // Not all rules are defined in the object literal\n// @ts-expect-error\nconst block = {\n    newline: /^(?: *(?:\\n|$))+/,\n    code: /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/,\n    fences: /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/,\n    hr: /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/,\n    heading: /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/,\n    blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n    list: /^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/,\n    html: \"^ {0,3}(?:\" // optional indentation\n     + \"<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)\" // (1)\n     + \"|comment[^\\\\n]*(\\\\n+|$)\" // (2)\n     + \"|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)\" // (3)\n     + \"|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)\" // (4)\n     + \"|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)\" // (5)\n     + \"|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (6)\n     + \"|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (7) open tag\n     + \"|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (7) closing tag\n     + \")\",\n    def: /^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/,\n    table: noopTest,\n    lheading: /^(?!bull )((?:.|\\n(?!\\s*?\\n|bull ))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    // regex template, placeholders will be replaced according to different paragraph\n    // interruption rules of commonmark and the original markdown spec:\n    _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/,\n    text: /^[^\\n]+/\n};\nblock._label = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nblock._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\nblock.def = edit(block.def).replace(\"label\", block._label).replace(\"title\", block._title).getRegex();\nblock.bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nblock.listItemStart = edit(/^( *)(bull) */).replace(\"bull\", block.bullet).getRegex();\nblock.list = edit(block.list).replace(/bull/g, block.bullet).replace(\"hr\", \"\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))\").replace(\"def\", \"\\\\n+(?=\" + block.def.source + \")\").getRegex();\nblock._tag = \"address|article|aside|base|basefont|blockquote|body|caption\" + \"|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption\" + \"|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe\" + \"|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option\" + \"|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr\" + \"|track|ul\";\nblock._comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\nblock.html = edit(block.html, \"i\").replace(\"comment\", block._comment).replace(\"tag\", block._tag).replace(\"attribute\", / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\nblock.lheading = edit(block.lheading).replace(/bull/g, block.bullet) // lists can interrupt\n.getRegex();\nblock.paragraph = edit(block._paragraph).replace(\"hr\", block.hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\", \"\") // setex headings don't interrupt commonmark paragraphs\n.replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", block._tag) // pars can be interrupted by type (6) html blocks\n.getRegex();\nblock.blockquote = edit(block.blockquote).replace(\"paragraph\", block.paragraph).getRegex();\n/**\n * Normal Block Grammar\n */ block.normal = {\n    ...block\n};\n/**\n * GFM Block Grammar\n */ block.gfm = {\n    ...block.normal,\n    table: \"^ *([^\\\\n ].*)\\\\n\" // Header\n     + \" {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)\" // Align\n     + \"(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)\" // Cells\n};\nblock.gfm.table = edit(block.gfm.table).replace(\"hr\", block.hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"blockquote\", \" {0,3}>\").replace(\"code\", \" {4}[^\\\\n]\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", block._tag) // tables can be interrupted by type (6) html blocks\n.getRegex();\nblock.gfm.paragraph = edit(block._paragraph).replace(\"hr\", block.hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\", \"\") // setex headings don't interrupt commonmark paragraphs\n.replace(\"table\", block.gfm.table) // interrupt paragraphs with table\n.replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", block._tag) // pars can be interrupted by type (6) html blocks\n.getRegex();\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */ block.pedantic = {\n    ...block.normal,\n    html: edit(\"^ *(?:comment *(?:\\\\n|\\\\s*$)\" + \"|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)\" // closed tag\n     + \"|<tag(?:\\\"[^\\\"]*\\\"|'[^']*'|\\\\s[^'\\\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))\").replace(\"comment\", block._comment).replace(/tag/g, \"(?!(?:\" + \"a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub\" + \"|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\" + \"\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b\").getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest,\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(block.normal._paragraph).replace(\"hr\", block.hr).replace(\"heading\", \" *#{1,6} *[^\\n]\").replace(\"lheading\", block.lheading).replace(\"blockquote\", \" {0,3}>\").replace(\"|fences\", \"\").replace(\"|list\", \"\").replace(\"|html\", \"\").getRegex()\n};\n/**\n * Inline-Level Grammar\n */ // Not all rules are defined in the object literal\n// @ts-expect-error\nconst inline = {\n    escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n    autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n    url: noopTest,\n    tag: \"^comment\" + \"|^</[a-zA-Z][\\\\w:-]*\\\\s*>\" // self-closing tag\n     + \"|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>\" // open tag\n     + \"|^<\\\\?[\\\\s\\\\S]*?\\\\?>\" // processing instruction, e.g. <?php ?>\n     + \"|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>\" // declaration, e.g. <!DOCTYPE html>\n     + \"|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\",\n    link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n    reflink: /^!?\\[(label)\\]\\[(ref)\\]/,\n    nolink: /^!?\\[(ref)\\](?:\\[\\])?/,\n    reflinkSearch: \"reflink|nolink(?!\\\\()\",\n    emStrong: {\n        lDelim: /^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/,\n        //         (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.\n        //         | Skip orphan inside strong      | Consume to delim | (1) #***              | (2) a***#, a***                    | (3) #***a, ***a                  | (4) ***#                 | (5) #***#                         | (6) a***a\n        rDelimAst: /^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])/,\n        rDelimUnd: /^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])/ // ^- Not allowed for _\n    },\n    code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n    br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n    del: noopTest,\n    text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/,\n    punctuation: /^((?![*_])[\\spunctuation])/\n};\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\ninline._punctuation = \"\\\\p{P}$+<=>`^|~\";\ninline.punctuation = edit(inline.punctuation, \"u\").replace(/punctuation/g, inline._punctuation).getRegex();\n// sequences em should skip over [title](link), `code`, <html>\ninline.blockSkip = /\\[[^[\\]]*?\\]\\([^\\(\\)]*?\\)|`[^`]*?`|<[^<>]*?>/g;\ninline.anyPunctuation = /\\\\[punct]/g;\ninline._escapes = /\\\\([punct])/g;\ninline._comment = edit(block._comment).replace(\"(?:-->|$)\", \"-->\").getRegex();\ninline.emStrong.lDelim = edit(inline.emStrong.lDelim, \"u\").replace(/punct/g, inline._punctuation).getRegex();\ninline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, \"gu\").replace(/punct/g, inline._punctuation).getRegex();\ninline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, \"gu\").replace(/punct/g, inline._punctuation).getRegex();\ninline.anyPunctuation = edit(inline.anyPunctuation, \"gu\").replace(/punct/g, inline._punctuation).getRegex();\ninline._escapes = edit(inline._escapes, \"gu\").replace(/punct/g, inline._punctuation).getRegex();\ninline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\ninline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\ninline.autolink = edit(inline.autolink).replace(\"scheme\", inline._scheme).replace(\"email\", inline._email).getRegex();\ninline._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\ninline.tag = edit(inline.tag).replace(\"comment\", inline._comment).replace(\"attribute\", inline._attribute).getRegex();\ninline._label = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\ninline._href = /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/;\ninline._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\ninline.link = edit(inline.link).replace(\"label\", inline._label).replace(\"href\", inline._href).replace(\"title\", inline._title).getRegex();\ninline.reflink = edit(inline.reflink).replace(\"label\", inline._label).replace(\"ref\", block._label).getRegex();\ninline.nolink = edit(inline.nolink).replace(\"ref\", block._label).getRegex();\ninline.reflinkSearch = edit(inline.reflinkSearch, \"g\").replace(\"reflink\", inline.reflink).replace(\"nolink\", inline.nolink).getRegex();\n/**\n * Normal Inline Grammar\n */ inline.normal = {\n    ...inline\n};\n/**\n * Pedantic Inline Grammar\n */ inline.pedantic = {\n    ...inline.normal,\n    strong: {\n        start: /^__|\\*\\*/,\n        middle: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n        endAst: /\\*\\*(?!\\*)/g,\n        endUnd: /__(?!_)/g\n    },\n    em: {\n        start: /^_|\\*/,\n        middle: /^()\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)|^_(?=\\S)([\\s\\S]*?\\S)_(?!_)/,\n        endAst: /\\*(?!\\*)/g,\n        endUnd: /_(?!_)/g\n    },\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace(\"label\", inline._label).getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace(\"label\", inline._label).getRegex()\n};\n/**\n * GFM Inline Grammar\n */ inline.gfm = {\n    ...inline.normal,\n    escape: edit(inline.escape).replace(\"])\", \"~|])\").getRegex(),\n    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n    url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n};\ninline.gfm.url = edit(inline.gfm.url, \"i\").replace(\"email\", inline.gfm._extended_email).getRegex();\n/**\n * GFM + Line Breaks Inline Grammar\n */ inline.breaks = {\n    ...inline.gfm,\n    br: edit(inline.br).replace(\"{2,}\", \"*\").getRegex(),\n    text: edit(inline.gfm.text).replace(\"\\\\b_\", \"\\\\b_| {2,}\\\\n\").replace(/\\{2,\\}/g, \"*\").getRegex()\n};\n/**\n * Block Lexer\n */ class _Lexer {\n    constructor(options){\n        // TokenList cannot be created in one go\n        // @ts-expect-error\n        this.tokens = [];\n        this.tokens.links = Object.create(null);\n        this.options = options || _defaults;\n        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true\n        };\n        const rules = {\n            block: block.normal,\n            inline: inline.normal\n        };\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        } else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n                rules.inline = inline.breaks;\n            } else {\n                rules.inline = inline.gfm;\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */ static get rules() {\n        return {\n            block,\n            inline\n        };\n    }\n    /**\n     * Static Lex Method\n     */ static lex(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */ static lexInline(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */ lex(src) {\n        src = src.replace(/\\r\\n|\\r/g, \"\\n\");\n        this.blockTokens(src, this.tokens);\n        let next;\n        while(next = this.inlineQueue.shift()){\n            this.inlineTokens(next.src, next.tokens);\n        }\n        return this.tokens;\n    }\n    blockTokens(src, tokens = []) {\n        if (this.options.pedantic) {\n            src = src.replace(/\\t/g, \"    \").replace(/^ +$/gm, \"\");\n        } else {\n            src = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs)=>{\n                return leading + \"    \".repeat(tabs.length);\n            });\n        }\n        let token;\n        let lastToken;\n        let cutSrc;\n        let lastParagraphClipped;\n        while(src){\n            if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer)=>{\n                if (token = extTokenizer.call({\n                    lexer: this\n                }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // newline\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.length === 1 && tokens.length > 0) {\n                    // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unnecessary paragraph tags\n                    tokens[tokens.length - 1].raw += \"\\n\";\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                // An indented code block cannot interrupt a paragraph.\n                if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // fences\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // heading\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // hr\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // blockquote\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // list\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // html\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // def\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.raw;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else if (!this.tokens.links[token.tag]) {\n                    this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title\n                    };\n                }\n                continue;\n            }\n            // table (gfm)\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // lheading\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // top-level paragraph\n            // prevent paragraph consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startBlock) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startBlock.forEach((getStartIndex)=>{\n                    tempStart = getStartIndex.call({\n                        lexer: this\n                    }, tempSrc);\n                    if (typeof tempStart === \"number\" && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                lastToken = tokens[tokens.length - 1];\n                if (lastParagraphClipped && lastToken.type === \"paragraph\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = cutSrc.length !== src.length;\n                src = src.substring(token.raw.length);\n                continue;\n            }\n            // text\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === \"text\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        this.state.top = true;\n        return tokens;\n    }\n    inline(src, tokens = []) {\n        this.inlineQueue.push({\n            src,\n            tokens\n        });\n        return tokens;\n    }\n    /**\n     * Lexing/Compiling\n     */ inlineTokens(src, tokens = []) {\n        let token, lastToken, cutSrc;\n        // String with links masked to avoid interference with em and strong\n        let maskedSrc = src;\n        let match;\n        let keepPrevChar, prevChar;\n        // Mask out reflinks\n        if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null){\n                    if (links.includes(match[0].slice(match[0].lastIndexOf(\"[\") + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        // Mask out other blocks\n        while((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null){\n            maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n        // Mask out escaped characters\n        while((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null){\n            maskedSrc = maskedSrc.slice(0, match.index) + \"++\" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n        }\n        while(src){\n            if (!keepPrevChar) {\n                prevChar = \"\";\n            }\n            keepPrevChar = false;\n            // extensions\n            if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer)=>{\n                if (token = extTokenizer.call({\n                    lexer: this\n                }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // escape\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // tag\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // link\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // reflink, nolink\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // em & strong\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // br\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // del (gfm)\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // autolink\n            if (token = this.tokenizer.autolink(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // url (gfm)\n            if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // text\n            // prevent inlineText consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startInline) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startInline.forEach((getStartIndex)=>{\n                    tempStart = getStartIndex.call({\n                        lexer: this\n                    }, tempSrc);\n                    if (typeof tempStart === \"number\" && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (token = this.tokenizer.inlineText(cutSrc)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== \"_\") {\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        return tokens;\n    }\n}\n/**\n * Renderer\n */ class _Renderer {\n    constructor(options){\n        this.options = options || _defaults;\n    }\n    code(code, infostring, escaped) {\n        const lang = (infostring || \"\").match(/^\\S*/)?.[0];\n        code = code.replace(/\\n$/, \"\") + \"\\n\";\n        if (!lang) {\n            return \"<pre><code>\" + (escaped ? code : escape(code, true)) + \"</code></pre>\\n\";\n        }\n        return '<pre><code class=\"language-' + escape(lang) + '\">' + (escaped ? code : escape(code, true)) + \"</code></pre>\\n\";\n    }\n    blockquote(quote) {\n        return `<blockquote>\\n${quote}</blockquote>\\n`;\n    }\n    html(html, block) {\n        return html;\n    }\n    heading(text, level, raw) {\n        // ignore IDs\n        return `<h${level}>${text}</h${level}>\\n`;\n    }\n    hr() {\n        return \"<hr>\\n\";\n    }\n    list(body, ordered, start) {\n        const type = ordered ? \"ol\" : \"ul\";\n        const startatt = ordered && start !== 1 ? ' start=\"' + start + '\"' : \"\";\n        return \"<\" + type + startatt + \">\\n\" + body + \"</\" + type + \">\\n\";\n    }\n    listitem(text, task, checked) {\n        return `<li>${text}</li>\\n`;\n    }\n    checkbox(checked) {\n        return \"<input \" + (checked ? 'checked=\"\" ' : \"\") + 'disabled=\"\" type=\"checkbox\">';\n    }\n    paragraph(text) {\n        return `<p>${text}</p>\\n`;\n    }\n    table(header, body) {\n        if (body) body = `<tbody>${body}</tbody>`;\n        return \"<table>\\n\" + \"<thead>\\n\" + header + \"</thead>\\n\" + body + \"</table>\\n\";\n    }\n    tablerow(content) {\n        return `<tr>\\n${content}</tr>\\n`;\n    }\n    tablecell(content, flags) {\n        const type = flags.header ? \"th\" : \"td\";\n        const tag = flags.align ? `<${type} align=\"${flags.align}\">` : `<${type}>`;\n        return tag + content + `</${type}>\\n`;\n    }\n    /**\n     * span level renderer\n     */ strong(text) {\n        return `<strong>${text}</strong>`;\n    }\n    em(text) {\n        return `<em>${text}</em>`;\n    }\n    codespan(text) {\n        return `<code>${text}</code>`;\n    }\n    br() {\n        return \"<br>\";\n    }\n    del(text) {\n        return `<del>${text}</del>`;\n    }\n    link(href, title, text) {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + title + '\"';\n        }\n        out += \">\" + text + \"</a>\";\n        return out;\n    }\n    image(href, title, text) {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = `<img src=\"${href}\" alt=\"${text}\"`;\n        if (title) {\n            out += ` title=\"${title}\"`;\n        }\n        out += \">\";\n        return out;\n    }\n    text(text) {\n        return text;\n    }\n}\n/**\n * TextRenderer\n * returns only the textual part of the token\n */ class _TextRenderer {\n    // no need for block level renderers\n    strong(text) {\n        return text;\n    }\n    em(text) {\n        return text;\n    }\n    codespan(text) {\n        return text;\n    }\n    del(text) {\n        return text;\n    }\n    html(text) {\n        return text;\n    }\n    text(text) {\n        return text;\n    }\n    link(href, title, text) {\n        return \"\" + text;\n    }\n    image(href, title, text) {\n        return \"\" + text;\n    }\n    br() {\n        return \"\";\n    }\n}\n/**\n * Parsing & Compiling\n */ class _Parser {\n    constructor(options){\n        this.options = options || _defaults;\n        this.options.renderer = this.options.renderer || new _Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.textRenderer = new _TextRenderer();\n    }\n    /**\n     * Static Parse Method\n     */ static parse(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */ static parseInline(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */ parse(tokens, top = true) {\n        let out = \"\";\n        for(let i = 0; i < tokens.length; i++){\n            const token = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                const genericToken = token;\n                const ret = this.options.extensions.renderers[genericToken.type].call({\n                    parser: this\n                }, genericToken);\n                if (ret !== false || ![\n                    \"space\",\n                    \"hr\",\n                    \"heading\",\n                    \"code\",\n                    \"table\",\n                    \"blockquote\",\n                    \"list\",\n                    \"html\",\n                    \"paragraph\",\n                    \"text\"\n                ].includes(genericToken.type)) {\n                    out += ret || \"\";\n                    continue;\n                }\n            }\n            switch(token.type){\n                case \"space\":\n                    {\n                        continue;\n                    }\n                case \"hr\":\n                    {\n                        out += this.renderer.hr();\n                        continue;\n                    }\n                case \"heading\":\n                    {\n                        const headingToken = token;\n                        out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape(this.parseInline(headingToken.tokens, this.textRenderer)));\n                        continue;\n                    }\n                case \"code\":\n                    {\n                        const codeToken = token;\n                        out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);\n                        continue;\n                    }\n                case \"table\":\n                    {\n                        const tableToken = token;\n                        let header = \"\";\n                        // header\n                        let cell = \"\";\n                        for(let j = 0; j < tableToken.header.length; j++){\n                            cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), {\n                                header: true,\n                                align: tableToken.align[j]\n                            });\n                        }\n                        header += this.renderer.tablerow(cell);\n                        let body = \"\";\n                        for(let j = 0; j < tableToken.rows.length; j++){\n                            const row = tableToken.rows[j];\n                            cell = \"\";\n                            for(let k = 0; k < row.length; k++){\n                                cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {\n                                    header: false,\n                                    align: tableToken.align[k]\n                                });\n                            }\n                            body += this.renderer.tablerow(cell);\n                        }\n                        out += this.renderer.table(header, body);\n                        continue;\n                    }\n                case \"blockquote\":\n                    {\n                        const blockquoteToken = token;\n                        const body = this.parse(blockquoteToken.tokens);\n                        out += this.renderer.blockquote(body);\n                        continue;\n                    }\n                case \"list\":\n                    {\n                        const listToken = token;\n                        const ordered = listToken.ordered;\n                        const start = listToken.start;\n                        const loose = listToken.loose;\n                        let body = \"\";\n                        for(let j = 0; j < listToken.items.length; j++){\n                            const item = listToken.items[j];\n                            const checked = item.checked;\n                            const task = item.task;\n                            let itemBody = \"\";\n                            if (item.task) {\n                                const checkbox = this.renderer.checkbox(!!checked);\n                                if (loose) {\n                                    if (item.tokens.length > 0 && item.tokens[0].type === \"paragraph\") {\n                                        item.tokens[0].text = checkbox + \" \" + item.tokens[0].text;\n                                        if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === \"text\") {\n                                            item.tokens[0].tokens[0].text = checkbox + \" \" + item.tokens[0].tokens[0].text;\n                                        }\n                                    } else {\n                                        item.tokens.unshift({\n                                            type: \"text\",\n                                            text: checkbox + \" \"\n                                        });\n                                    }\n                                } else {\n                                    itemBody += checkbox + \" \";\n                                }\n                            }\n                            itemBody += this.parse(item.tokens, loose);\n                            body += this.renderer.listitem(itemBody, task, !!checked);\n                        }\n                        out += this.renderer.list(body, ordered, start);\n                        continue;\n                    }\n                case \"html\":\n                    {\n                        const htmlToken = token;\n                        out += this.renderer.html(htmlToken.text, htmlToken.block);\n                        continue;\n                    }\n                case \"paragraph\":\n                    {\n                        const paragraphToken = token;\n                        out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));\n                        continue;\n                    }\n                case \"text\":\n                    {\n                        let textToken = token;\n                        let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;\n                        while(i + 1 < tokens.length && tokens[i + 1].type === \"text\"){\n                            textToken = tokens[++i];\n                            body += \"\\n\" + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);\n                        }\n                        out += top ? this.renderer.paragraph(body) : body;\n                        continue;\n                    }\n                default:\n                    {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return \"\";\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    }\n            }\n        }\n        return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */ parseInline(tokens, renderer) {\n        renderer = renderer || this.renderer;\n        let out = \"\";\n        for(let i = 0; i < tokens.length; i++){\n            const token = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                const ret = this.options.extensions.renderers[token.type].call({\n                    parser: this\n                }, token);\n                if (ret !== false || ![\n                    \"escape\",\n                    \"html\",\n                    \"link\",\n                    \"image\",\n                    \"strong\",\n                    \"em\",\n                    \"codespan\",\n                    \"br\",\n                    \"del\",\n                    \"text\"\n                ].includes(token.type)) {\n                    out += ret || \"\";\n                    continue;\n                }\n            }\n            switch(token.type){\n                case \"escape\":\n                    {\n                        const escapeToken = token;\n                        out += renderer.text(escapeToken.text);\n                        break;\n                    }\n                case \"html\":\n                    {\n                        const tagToken = token;\n                        out += renderer.html(tagToken.text);\n                        break;\n                    }\n                case \"link\":\n                    {\n                        const linkToken = token;\n                        out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));\n                        break;\n                    }\n                case \"image\":\n                    {\n                        const imageToken = token;\n                        out += renderer.image(imageToken.href, imageToken.title, imageToken.text);\n                        break;\n                    }\n                case \"strong\":\n                    {\n                        const strongToken = token;\n                        out += renderer.strong(this.parseInline(strongToken.tokens, renderer));\n                        break;\n                    }\n                case \"em\":\n                    {\n                        const emToken = token;\n                        out += renderer.em(this.parseInline(emToken.tokens, renderer));\n                        break;\n                    }\n                case \"codespan\":\n                    {\n                        const codespanToken = token;\n                        out += renderer.codespan(codespanToken.text);\n                        break;\n                    }\n                case \"br\":\n                    {\n                        out += renderer.br();\n                        break;\n                    }\n                case \"del\":\n                    {\n                        const delToken = token;\n                        out += renderer.del(this.parseInline(delToken.tokens, renderer));\n                        break;\n                    }\n                case \"text\":\n                    {\n                        const textToken = token;\n                        out += renderer.text(textToken.text);\n                        break;\n                    }\n                default:\n                    {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return \"\";\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    }\n            }\n        }\n        return out;\n    }\n}\nclass _Hooks {\n    constructor(options){\n        this.options = options || _defaults;\n    }\n    static{\n        this.passThroughHooks = new Set([\n            \"preprocess\",\n            \"postprocess\"\n        ]);\n    }\n    /**\n     * Process markdown before marked\n     */ preprocess(markdown) {\n        return markdown;\n    }\n    /**\n     * Process HTML after marked is finished\n     */ postprocess(html) {\n        return html;\n    }\n}\nclass Marked {\n    constructor(...args){\n        this.defaults = _getDefaults();\n        this.options = this.setOptions;\n        this.parse = this.#parseMarkdown(_Lexer.lex, _Parser.parse);\n        this.parseInline = this.#parseMarkdown(_Lexer.lexInline, _Parser.parseInline);\n        this.Parser = _Parser;\n        this.Renderer = _Renderer;\n        this.TextRenderer = _TextRenderer;\n        this.Lexer = _Lexer;\n        this.Tokenizer = _Tokenizer;\n        this.Hooks = _Hooks;\n        this.use(...args);\n    }\n    /**\n     * Run callback for every token\n     */ walkTokens(tokens, callback) {\n        let values = [];\n        for (const token of tokens){\n            values = values.concat(callback.call(this, token));\n            switch(token.type){\n                case \"table\":\n                    {\n                        const tableToken = token;\n                        for (const cell of tableToken.header){\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                        for (const row of tableToken.rows){\n                            for (const cell of row){\n                                values = values.concat(this.walkTokens(cell.tokens, callback));\n                            }\n                        }\n                        break;\n                    }\n                case \"list\":\n                    {\n                        const listToken = token;\n                        values = values.concat(this.walkTokens(listToken.items, callback));\n                        break;\n                    }\n                default:\n                    {\n                        const genericToken = token;\n                        if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens)=>{\n                                values = values.concat(this.walkTokens(genericToken[childTokens], callback));\n                            });\n                        } else if (genericToken.tokens) {\n                            values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                        }\n                    }\n            }\n        }\n        return values;\n    }\n    use(...args) {\n        const extensions = this.defaults.extensions || {\n            renderers: {},\n            childTokens: {}\n        };\n        args.forEach((pack)=>{\n            // copy options to new object\n            const opts = {\n                ...pack\n            };\n            // set async to true if it was set to true before\n            opts.async = this.defaults.async || opts.async || false;\n            // ==-- Parse \"addon\" extensions --== //\n            if (pack.extensions) {\n                pack.extensions.forEach((ext)=>{\n                    if (!ext.name) {\n                        throw new Error(\"extension name required\");\n                    }\n                    if (\"renderer\" in ext) {\n                        const prevRenderer = extensions.renderers[ext.name];\n                        if (prevRenderer) {\n                            // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function(...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) {\n                                    ret = prevRenderer.apply(this, args);\n                                }\n                                return ret;\n                            };\n                        } else {\n                            extensions.renderers[ext.name] = ext.renderer;\n                        }\n                    }\n                    if (\"tokenizer\" in ext) {\n                        if (!ext.level || ext.level !== \"block\" && ext.level !== \"inline\") {\n                            throw new Error(\"extension level must be 'block' or 'inline'\");\n                        }\n                        const extLevel = extensions[ext.level];\n                        if (extLevel) {\n                            extLevel.unshift(ext.tokenizer);\n                        } else {\n                            extensions[ext.level] = [\n                                ext.tokenizer\n                            ];\n                        }\n                        if (ext.start) {\n                            if (ext.level === \"block\") {\n                                if (extensions.startBlock) {\n                                    extensions.startBlock.push(ext.start);\n                                } else {\n                                    extensions.startBlock = [\n                                        ext.start\n                                    ];\n                                }\n                            } else if (ext.level === \"inline\") {\n                                if (extensions.startInline) {\n                                    extensions.startInline.push(ext.start);\n                                } else {\n                                    extensions.startInline = [\n                                        ext.start\n                                    ];\n                                }\n                            }\n                        }\n                    }\n                    if (\"childTokens\" in ext && ext.childTokens) {\n                        extensions.childTokens[ext.name] = ext.childTokens;\n                    }\n                });\n                opts.extensions = extensions;\n            }\n            // ==-- Parse \"overwrite\" extensions --== //\n            if (pack.renderer) {\n                const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                for(const prop in pack.renderer){\n                    const rendererFunc = pack.renderer[prop];\n                    const rendererKey = prop;\n                    const prevRenderer = renderer[rendererKey];\n                    // Replace renderer with func to run extension, but fall back if false\n                    renderer[rendererKey] = (...args)=>{\n                        let ret = rendererFunc.apply(renderer, args);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args);\n                        }\n                        return ret || \"\";\n                    };\n                }\n                opts.renderer = renderer;\n            }\n            if (pack.tokenizer) {\n                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                for(const prop in pack.tokenizer){\n                    const tokenizerFunc = pack.tokenizer[prop];\n                    const tokenizerKey = prop;\n                    const prevTokenizer = tokenizer[tokenizerKey];\n                    // Replace tokenizer with func to run extension, but fall back if false\n                    tokenizer[tokenizerKey] = (...args)=>{\n                        let ret = tokenizerFunc.apply(tokenizer, args);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args);\n                        }\n                        return ret;\n                    };\n                }\n                opts.tokenizer = tokenizer;\n            }\n            // ==-- Parse Hooks extensions --== //\n            if (pack.hooks) {\n                const hooks = this.defaults.hooks || new _Hooks();\n                for(const prop in pack.hooks){\n                    const hooksFunc = pack.hooks[prop];\n                    const hooksKey = prop;\n                    const prevHook = hooks[hooksKey];\n                    if (_Hooks.passThroughHooks.has(prop)) {\n                        hooks[hooksKey] = (arg)=>{\n                            if (this.defaults.async) {\n                                return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret)=>{\n                                    return prevHook.call(hooks, ret);\n                                });\n                            }\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    } else {\n                        hooks[hooksKey] = (...args)=>{\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args);\n                            }\n                            return ret;\n                        };\n                    }\n                }\n                opts.hooks = hooks;\n            }\n            // ==-- Parse WalkTokens extensions --== //\n            if (pack.walkTokens) {\n                const walkTokens = this.defaults.walkTokens;\n                const packWalktokens = pack.walkTokens;\n                opts.walkTokens = function(token) {\n                    let values = [];\n                    values.push(packWalktokens.call(this, token));\n                    if (walkTokens) {\n                        values = values.concat(walkTokens.call(this, token));\n                    }\n                    return values;\n                };\n            }\n            this.defaults = {\n                ...this.defaults,\n                ...opts\n            };\n        });\n        return this;\n    }\n    setOptions(opt) {\n        this.defaults = {\n            ...this.defaults,\n            ...opt\n        };\n        return this;\n    }\n    lexer(src, options) {\n        return _Lexer.lex(src, options ?? this.defaults);\n    }\n    parser(tokens, options) {\n        return _Parser.parse(tokens, options ?? this.defaults);\n    }\n    #parseMarkdown(lexer, parser) {\n        return (src, options)=>{\n            const origOpt = {\n                ...options\n            };\n            const opt = {\n                ...this.defaults,\n                ...origOpt\n            };\n            // Show warning if an extension set async to true but the parse was called with async: false\n            if (this.defaults.async === true && origOpt.async === false) {\n                if (!opt.silent) {\n                    console.warn(\"marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.\");\n                }\n                opt.async = true;\n            }\n            const throwError = this.#onError(!!opt.silent, !!opt.async);\n            // throw error in case of non string input\n            if (typeof src === \"undefined\" || src === null) {\n                return throwError(new Error(\"marked(): input parameter is undefined or null\"));\n            }\n            if (typeof src !== \"string\") {\n                return throwError(new Error(\"marked(): input parameter is of type \" + Object.prototype.toString.call(src) + \", string expected\"));\n            }\n            if (opt.hooks) {\n                opt.hooks.options = opt;\n            }\n            if (opt.async) {\n                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src)=>lexer(src, opt)).then((tokens)=>opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(()=>tokens) : tokens).then((tokens)=>parser(tokens, opt)).then((html)=>opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);\n            }\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src);\n                }\n                const tokens = lexer(src, opt);\n                if (opt.walkTokens) {\n                    this.walkTokens(tokens, opt.walkTokens);\n                }\n                let html = parser(tokens, opt);\n                if (opt.hooks) {\n                    html = opt.hooks.postprocess(html);\n                }\n                return html;\n            } catch (e) {\n                return throwError(e);\n            }\n        };\n    }\n    #onError(silent, async) {\n        return (e)=>{\n            e.message += \"\\nPlease report this to https://github.com/markedjs/marked.\";\n            if (silent) {\n                const msg = \"<p>An error occurred:</p><pre>\" + escape(e.message + \"\", true) + \"</pre>\";\n                if (async) {\n                    return Promise.resolve(msg);\n                }\n                return msg;\n            }\n            if (async) {\n                return Promise.reject(e);\n            }\n            throw e;\n        };\n    }\n}\nconst markedInstance = new Marked();\nfunction marked(src, opt) {\n    return markedInstance.parse(src, opt);\n}\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */ marked.options = marked.setOptions = function(options) {\n    markedInstance.setOptions(options);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Gets the original marked default options.\n */ marked.getDefaults = _getDefaults;\nmarked.defaults = _defaults;\n/**\n * Use Extension\n */ marked.use = function(...args) {\n    markedInstance.use(...args);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Run callback for every token\n */ marked.walkTokens = function(tokens, callback) {\n    return markedInstance.walkTokens(tokens, callback);\n};\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */ marked.parseInline = markedInstance.parseInline;\n/**\n * Expose\n */ marked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\nconst options = marked.options;\nconst setOptions = marked.setOptions;\nconst use = marked.use;\nconst walkTokens = marked.walkTokens;\nconst parseInline = marked.parseInline;\nconst parse = marked;\nconst parser = _Parser.parse;\nconst lexer = _Lexer.lex;\n //# sourceMappingURL=marked.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21hcmtlZEAxMC4wLjAvbm9kZV9tb2R1bGVzL21hcmtlZC9saWIvbWFya2VkLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBRUQ7OztDQUdDLEdBRUQ7O0NBRUMsR0FDRCxTQUFTQTtJQUNMLE9BQU87UUFDSEMsT0FBTztRQUNQQyxRQUFRO1FBQ1JDLFlBQVk7UUFDWkMsS0FBSztRQUNMQyxPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsVUFBVTtRQUNWQyxRQUFRO1FBQ1JDLFdBQVc7UUFDWEMsWUFBWTtJQUNoQjtBQUNKO0FBQ0EsSUFBSUMsWUFBWVg7QUFDaEIsU0FBU1ksZUFBZUMsV0FBVztJQUMvQkYsWUFBWUU7QUFDaEI7QUFFQTs7Q0FFQyxHQUNELE1BQU1DLGFBQWE7QUFDbkIsTUFBTUMsZ0JBQWdCLElBQUlDLE9BQU9GLFdBQVdHLE1BQU0sRUFBRTtBQUNwRCxNQUFNQyxxQkFBcUI7QUFDM0IsTUFBTUMsd0JBQXdCLElBQUlILE9BQU9FLG1CQUFtQkQsTUFBTSxFQUFFO0FBQ3BFLE1BQU1HLHFCQUFxQjtJQUN2QixLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztBQUNUO0FBQ0EsTUFBTUMsdUJBQXVCLENBQUNDLEtBQU9GLGtCQUFrQixDQUFDRSxHQUFHO0FBQzNELFNBQVNDLE9BQU9DLElBQUksRUFBRUMsTUFBTTtJQUN4QixJQUFJQSxRQUFRO1FBQ1IsSUFBSVgsV0FBV1ksSUFBSSxDQUFDRixPQUFPO1lBQ3ZCLE9BQU9BLEtBQUtHLE9BQU8sQ0FBQ1osZUFBZU07UUFDdkM7SUFDSixPQUNLO1FBQ0QsSUFBSUgsbUJBQW1CUSxJQUFJLENBQUNGLE9BQU87WUFDL0IsT0FBT0EsS0FBS0csT0FBTyxDQUFDUix1QkFBdUJFO1FBQy9DO0lBQ0o7SUFDQSxPQUFPRztBQUNYO0FBQ0EsTUFBTUksZUFBZTtBQUNyQixTQUFTQyxT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dWxlcy8ucG5wbS9tYXJrZWRAMTAuMC4wL25vZGVfbW9kdWxlcy9tYXJrZWQvbGliL21hcmtlZC5lc20uanM/NTIwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIG1hcmtlZCB2MTAuMC4wIC0gYSBtYXJrZG93biBwYXJzZXJcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDIzLCBDaHJpc3RvcGhlciBKZWZmcmV5LiAoTUlUIExpY2Vuc2VkKVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZFxuICovXG5cbi8qKlxuICogRE8gTk9UIEVESVQgVEhJUyBGSUxFXG4gKiBUaGUgY29kZSBpbiB0aGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gZmlsZXMgaW4gLi9zcmMvXG4gKi9cblxuLyoqXG4gKiBHZXRzIHRoZSBvcmlnaW5hbCBtYXJrZWQgZGVmYXVsdCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBfZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXN5bmM6IGZhbHNlLFxuICAgICAgICBicmVha3M6IGZhbHNlLFxuICAgICAgICBleHRlbnNpb25zOiBudWxsLFxuICAgICAgICBnZm06IHRydWUsXG4gICAgICAgIGhvb2tzOiBudWxsLFxuICAgICAgICBwZWRhbnRpYzogZmFsc2UsXG4gICAgICAgIHJlbmRlcmVyOiBudWxsLFxuICAgICAgICBzaWxlbnQ6IGZhbHNlLFxuICAgICAgICB0b2tlbml6ZXI6IG51bGwsXG4gICAgICAgIHdhbGtUb2tlbnM6IG51bGxcbiAgICB9O1xufVxubGV0IF9kZWZhdWx0cyA9IF9nZXREZWZhdWx0cygpO1xuZnVuY3Rpb24gY2hhbmdlRGVmYXVsdHMobmV3RGVmYXVsdHMpIHtcbiAgICBfZGVmYXVsdHMgPSBuZXdEZWZhdWx0cztcbn1cblxuLyoqXG4gKiBIZWxwZXJzXG4gKi9cbmNvbnN0IGVzY2FwZVRlc3QgPSAvWyY8PlwiJ10vO1xuY29uc3QgZXNjYXBlUmVwbGFjZSA9IG5ldyBSZWdFeHAoZXNjYXBlVGVzdC5zb3VyY2UsICdnJyk7XG5jb25zdCBlc2NhcGVUZXN0Tm9FbmNvZGUgPSAvWzw+XCInXXwmKD8hKCNcXGR7MSw3fXwjW1h4XVthLWZBLUYwLTldezEsNn18XFx3Kyk7KS87XG5jb25zdCBlc2NhcGVSZXBsYWNlTm9FbmNvZGUgPSBuZXcgUmVnRXhwKGVzY2FwZVRlc3ROb0VuY29kZS5zb3VyY2UsICdnJyk7XG5jb25zdCBlc2NhcGVSZXBsYWNlbWVudHMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnXG59O1xuY29uc3QgZ2V0RXNjYXBlUmVwbGFjZW1lbnQgPSAoY2gpID0+IGVzY2FwZVJlcGxhY2VtZW50c1tjaF07XG5mdW5jdGlvbiBlc2NhcGUoaHRtbCwgZW5jb2RlKSB7XG4gICAgaWYgKGVuY29kZSkge1xuICAgICAgICBpZiAoZXNjYXBlVGVzdC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGVzY2FwZVJlcGxhY2UsIGdldEVzY2FwZVJlcGxhY2VtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGVzY2FwZVRlc3ROb0VuY29kZS50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGVzY2FwZVJlcGxhY2VOb0VuY29kZSwgZ2V0RXNjYXBlUmVwbGFjZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xufVxuY29uc3QgdW5lc2NhcGVUZXN0ID0gLyYoIyg/OlxcZCspfCg/OiN4WzAtOUEtRmEtZl0rKXwoPzpcXHcrKSk7Py9pZztcbmZ1bmN0aW9uIHVuZXNjYXBlKGh0bWwpIHtcbiAgICAvLyBleHBsaWNpdGx5IG1hdGNoIGRlY2ltYWwsIGhleCwgYW5kIG5hbWVkIEhUTUwgZW50aXRpZXNcbiAgICByZXR1cm4gaHRtbC5yZXBsYWNlKHVuZXNjYXBlVGVzdCwgKF8sIG4pID0+IHtcbiAgICAgICAgbiA9IG4udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKG4gPT09ICdjb2xvbicpXG4gICAgICAgICAgICByZXR1cm4gJzonO1xuICAgICAgICBpZiAobi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgICAgcmV0dXJuIG4uY2hhckF0KDEpID09PSAneCdcbiAgICAgICAgICAgICAgICA/IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQobi5zdWJzdHJpbmcoMiksIDE2KSlcbiAgICAgICAgICAgICAgICA6IFN0cmluZy5mcm9tQ2hhckNvZGUoK24uc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfSk7XG59XG5jb25zdCBjYXJldCA9IC8oXnxbXlxcW10pXFxeL2c7XG5mdW5jdGlvbiBlZGl0KHJlZ2V4LCBvcHQpIHtcbiAgICByZWdleCA9IHR5cGVvZiByZWdleCA9PT0gJ3N0cmluZycgPyByZWdleCA6IHJlZ2V4LnNvdXJjZTtcbiAgICBvcHQgPSBvcHQgfHwgJyc7XG4gICAgY29uc3Qgb2JqID0ge1xuICAgICAgICByZXBsYWNlOiAobmFtZSwgdmFsKSA9PiB7XG4gICAgICAgICAgICB2YWwgPSB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiAnc291cmNlJyBpbiB2YWwgPyB2YWwuc291cmNlIDogdmFsO1xuICAgICAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoY2FyZXQsICckMScpO1xuICAgICAgICAgICAgcmVnZXggPSByZWdleC5yZXBsYWNlKG5hbWUsIHZhbCk7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LFxuICAgICAgICBnZXRSZWdleDogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXgsIG9wdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBjbGVhblVybChocmVmKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaHJlZiA9IGVuY29kZVVSSShocmVmKS5yZXBsYWNlKC8lMjUvZywgJyUnKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBocmVmO1xufVxuY29uc3Qgbm9vcFRlc3QgPSB7IGV4ZWM6ICgpID0+IG51bGwgfTtcbmZ1bmN0aW9uIHNwbGl0Q2VsbHModGFibGVSb3csIGNvdW50KSB7XG4gICAgLy8gZW5zdXJlIHRoYXQgZXZlcnkgY2VsbC1kZWxpbWl0aW5nIHBpcGUgaGFzIGEgc3BhY2VcbiAgICAvLyBiZWZvcmUgaXQgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbSBhbiBlc2NhcGVkIHBpcGVcbiAgICBjb25zdCByb3cgPSB0YWJsZVJvdy5yZXBsYWNlKC9cXHwvZywgKG1hdGNoLCBvZmZzZXQsIHN0cikgPT4ge1xuICAgICAgICBsZXQgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgY3VyciA9IG9mZnNldDtcbiAgICAgICAgd2hpbGUgKC0tY3VyciA+PSAwICYmIHN0cltjdXJyXSA9PT0gJ1xcXFwnKVxuICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgICAgICAgLy8gb2RkIG51bWJlciBvZiBzbGFzaGVzIG1lYW5zIHwgaXMgZXNjYXBlZFxuICAgICAgICAgICAgLy8gc28gd2UgbGVhdmUgaXQgYWxvbmVcbiAgICAgICAgICAgIHJldHVybiAnfCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhZGQgc3BhY2UgYmVmb3JlIHVuZXNjYXBlZCB8XG4gICAgICAgICAgICByZXR1cm4gJyB8JztcbiAgICAgICAgfVxuICAgIH0pLCBjZWxscyA9IHJvdy5zcGxpdCgvIFxcfC8pO1xuICAgIGxldCBpID0gMDtcbiAgICAvLyBGaXJzdC9sYXN0IGNlbGwgaW4gYSByb3cgY2Fubm90IGJlIGVtcHR5IGlmIGl0IGhhcyBubyBsZWFkaW5nL3RyYWlsaW5nIHBpcGVcbiAgICBpZiAoIWNlbGxzWzBdLnRyaW0oKSkge1xuICAgICAgICBjZWxscy5zaGlmdCgpO1xuICAgIH1cbiAgICBpZiAoY2VsbHMubGVuZ3RoID4gMCAmJiAhY2VsbHNbY2VsbHMubGVuZ3RoIC0gMV0udHJpbSgpKSB7XG4gICAgICAgIGNlbGxzLnBvcCgpO1xuICAgIH1cbiAgICBpZiAoY291bnQpIHtcbiAgICAgICAgaWYgKGNlbGxzLmxlbmd0aCA+IGNvdW50KSB7XG4gICAgICAgICAgICBjZWxscy5zcGxpY2UoY291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKGNlbGxzLmxlbmd0aCA8IGNvdW50KVxuICAgICAgICAgICAgICAgIGNlbGxzLnB1c2goJycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gbGVhZGluZyBvciB0cmFpbGluZyB3aGl0ZXNwYWNlIGlzIGlnbm9yZWQgcGVyIHRoZSBnZm0gc3BlY1xuICAgICAgICBjZWxsc1tpXSA9IGNlbGxzW2ldLnRyaW0oKS5yZXBsYWNlKC9cXFxcXFx8L2csICd8Jyk7XG4gICAgfVxuICAgIHJldHVybiBjZWxscztcbn1cbi8qKlxuICogUmVtb3ZlIHRyYWlsaW5nICdjJ3MuIEVxdWl2YWxlbnQgdG8gc3RyLnJlcGxhY2UoL2MqJC8sICcnKS5cbiAqIC9jKiQvIGlzIHZ1bG5lcmFibGUgdG8gUkVET1MuXG4gKlxuICogQHBhcmFtIHN0clxuICogQHBhcmFtIGNcbiAqIEBwYXJhbSBpbnZlcnQgUmVtb3ZlIHN1ZmZpeCBvZiBub24tYyBjaGFycyBpbnN0ZWFkLiBEZWZhdWx0IGZhbHNleS5cbiAqL1xuZnVuY3Rpb24gcnRyaW0oc3RyLCBjLCBpbnZlcnQpIHtcbiAgICBjb25zdCBsID0gc3RyLmxlbmd0aDtcbiAgICBpZiAobCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIC8vIExlbmd0aCBvZiBzdWZmaXggbWF0Y2hpbmcgdGhlIGludmVydCBjb25kaXRpb24uXG4gICAgbGV0IHN1ZmZMZW4gPSAwO1xuICAgIC8vIFN0ZXAgbGVmdCB1bnRpbCB3ZSBmYWlsIHRvIG1hdGNoIHRoZSBpbnZlcnQgY29uZGl0aW9uLlxuICAgIHdoaWxlIChzdWZmTGVuIDwgbCkge1xuICAgICAgICBjb25zdCBjdXJyQ2hhciA9IHN0ci5jaGFyQXQobCAtIHN1ZmZMZW4gLSAxKTtcbiAgICAgICAgaWYgKGN1cnJDaGFyID09PSBjICYmICFpbnZlcnQpIHtcbiAgICAgICAgICAgIHN1ZmZMZW4rKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyQ2hhciAhPT0gYyAmJiBpbnZlcnQpIHtcbiAgICAgICAgICAgIHN1ZmZMZW4rKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHIuc2xpY2UoMCwgbCAtIHN1ZmZMZW4pO1xufVxuZnVuY3Rpb24gZmluZENsb3NpbmdCcmFja2V0KHN0ciwgYikge1xuICAgIGlmIChzdHIuaW5kZXhPZihiWzFdKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBsZXQgbGV2ZWwgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHJbaV0gPT09ICdcXFxcJykge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0cltpXSA9PT0gYlswXSkge1xuICAgICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHJbaV0gPT09IGJbMV0pIHtcbiAgICAgICAgICAgIGxldmVsLS07XG4gICAgICAgICAgICBpZiAobGV2ZWwgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBvdXRwdXRMaW5rKGNhcCwgbGluaywgcmF3LCBsZXhlcikge1xuICAgIGNvbnN0IGhyZWYgPSBsaW5rLmhyZWY7XG4gICAgY29uc3QgdGl0bGUgPSBsaW5rLnRpdGxlID8gZXNjYXBlKGxpbmsudGl0bGUpIDogbnVsbDtcbiAgICBjb25zdCB0ZXh0ID0gY2FwWzFdLnJlcGxhY2UoL1xcXFwoW1xcW1xcXV0pL2csICckMScpO1xuICAgIGlmIChjYXBbMF0uY2hhckF0KDApICE9PSAnIScpIHtcbiAgICAgICAgbGV4ZXIuc3RhdGUuaW5MaW5rID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdG9rZW4gPSB7XG4gICAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgICByYXcsXG4gICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgdG9rZW5zOiBsZXhlci5pbmxpbmVUb2tlbnModGV4dClcbiAgICAgICAgfTtcbiAgICAgICAgbGV4ZXIuc3RhdGUuaW5MaW5rID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgcmF3LFxuICAgICAgICBocmVmLFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgdGV4dDogZXNjYXBlKHRleHQpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluZGVudENvZGVDb21wZW5zYXRpb24ocmF3LCB0ZXh0KSB7XG4gICAgY29uc3QgbWF0Y2hJbmRlbnRUb0NvZGUgPSByYXcubWF0Y2goL14oXFxzKykoPzpgYGApLyk7XG4gICAgaWYgKG1hdGNoSW5kZW50VG9Db2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBjb25zdCBpbmRlbnRUb0NvZGUgPSBtYXRjaEluZGVudFRvQ29kZVsxXTtcbiAgICByZXR1cm4gdGV4dFxuICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgIC5tYXAobm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoSW5kZW50SW5Ob2RlID0gbm9kZS5tYXRjaCgvXlxccysvKTtcbiAgICAgICAgaWYgKG1hdGNoSW5kZW50SW5Ob2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbaW5kZW50SW5Ob2RlXSA9IG1hdGNoSW5kZW50SW5Ob2RlO1xuICAgICAgICBpZiAoaW5kZW50SW5Ob2RlLmxlbmd0aCA+PSBpbmRlbnRUb0NvZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5zbGljZShpbmRlbnRUb0NvZGUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9KVxuICAgICAgICAuam9pbignXFxuJyk7XG59XG4vKipcbiAqIFRva2VuaXplclxuICovXG5jbGFzcyBfVG9rZW5pemVyIHtcbiAgICBvcHRpb25zO1xuICAgIC8vIFRPRE86IEZpeCB0aGlzIHJ1bGVzIHR5cGVcbiAgICBydWxlcztcbiAgICBsZXhlcjtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgX2RlZmF1bHRzO1xuICAgIH1cbiAgICBzcGFjZShzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5uZXdsaW5lLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCAmJiBjYXBbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3BhY2UnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvZGUoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suY29kZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBjYXBbMF0ucmVwbGFjZSgvXiB7MSw0fS9nbSwgJycpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgY29kZUJsb2NrU3R5bGU6ICdpbmRlbnRlZCcsXG4gICAgICAgICAgICAgICAgdGV4dDogIXRoaXMub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICAgICAgICAgICAgICA/IHJ0cmltKHRleHQsICdcXG4nKVxuICAgICAgICAgICAgICAgICAgICA6IHRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmVuY2VzKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmZlbmNlcy5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHJhdyA9IGNhcFswXTtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBpbmRlbnRDb2RlQ29tcGVuc2F0aW9uKHJhdywgY2FwWzNdIHx8ICcnKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgICAgICAgIHJhdyxcbiAgICAgICAgICAgICAgICBsYW5nOiBjYXBbMl0gPyBjYXBbMl0udHJpbSgpLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogY2FwWzJdLFxuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGVhZGluZyhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oZWFkaW5nLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBjYXBbMl0udHJpbSgpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nICNzXG4gICAgICAgICAgICBpZiAoLyMkLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZCA9IHJ0cmltKHRleHQsICcjJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0cmltbWVkIHx8IC8gJC8udGVzdCh0cmltbWVkKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21tb25NYXJrIHJlcXVpcmVzIHNwYWNlIGJlZm9yZSB0cmFpbGluZyAjc1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgZGVwdGg6IGNhcFsxXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKHRleHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGhyKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmhyLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaHInLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGJsb2NrcXVvdGUoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suYmxvY2txdW90ZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBydHJpbShjYXBbMF0ucmVwbGFjZSgvXiAqPlsgXFx0XT8vZ20sICcnKSwgJ1xcbicpO1xuICAgICAgICAgICAgY29uc3QgdG9wID0gdGhpcy5sZXhlci5zdGF0ZS50b3A7XG4gICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLnRvcCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCB0b2tlbnMgPSB0aGlzLmxleGVyLmJsb2NrVG9rZW5zKHRleHQpO1xuICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS50b3AgPSB0b3A7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdibG9ja3F1b3RlJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0b2tlbnMsXG4gICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsaXN0KHNyYykge1xuICAgICAgICBsZXQgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5saXN0LmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IGJ1bGwgPSBjYXBbMV0udHJpbSgpO1xuICAgICAgICAgICAgY29uc3QgaXNvcmRlcmVkID0gYnVsbC5sZW5ndGggPiAxO1xuICAgICAgICAgICAgY29uc3QgbGlzdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICAgICAgICAgICAgcmF3OiAnJyxcbiAgICAgICAgICAgICAgICBvcmRlcmVkOiBpc29yZGVyZWQsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGlzb3JkZXJlZCA/ICtidWxsLnNsaWNlKDAsIC0xKSA6ICcnLFxuICAgICAgICAgICAgICAgIGxvb3NlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBidWxsID0gaXNvcmRlcmVkID8gYFxcXFxkezEsOX1cXFxcJHtidWxsLnNsaWNlKC0xKX1gIDogYFxcXFwke2J1bGx9YDtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICBidWxsID0gaXNvcmRlcmVkID8gYnVsbCA6ICdbKistXSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgbmV4dCBsaXN0IGl0ZW1cbiAgICAgICAgICAgIGNvbnN0IGl0ZW1SZWdleCA9IG5ldyBSZWdFeHAoYF4oIHswLDN9JHtidWxsfSkoKD86W1xcdCBdW15cXFxcbl0qKT8oPzpcXFxcbnwkKSlgKTtcbiAgICAgICAgICAgIGxldCByYXcgPSAnJztcbiAgICAgICAgICAgIGxldCBpdGVtQ29udGVudHMgPSAnJztcbiAgICAgICAgICAgIGxldCBlbmRzV2l0aEJsYW5rTGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgY3VycmVudCBidWxsZXQgcG9pbnQgY2FuIHN0YXJ0IGEgbmV3IExpc3QgSXRlbVxuICAgICAgICAgICAgd2hpbGUgKHNyYykge1xuICAgICAgICAgICAgICAgIGxldCBlbmRFYXJseSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICghKGNhcCA9IGl0ZW1SZWdleC5leGVjKHNyYykpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ydWxlcy5ibG9jay5oci50ZXN0KHNyYykpIHsgLy8gRW5kIGxpc3QgaWYgYnVsbGV0IHdhcyBhY3R1YWxseSBIUiAocG9zc2libHkgbW92ZSBpbnRvIGl0ZW1SZWdleD8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByYXcgPSBjYXBbMF07XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhyYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IGNhcFsyXS5zcGxpdCgnXFxuJywgMSlbMF0ucmVwbGFjZSgvXlxcdCsvLCAodCkgPT4gJyAnLnJlcGVhdCgzICogdC5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dExpbmUgPSBzcmMuc3BsaXQoJ1xcbicsIDEpWzBdO1xuICAgICAgICAgICAgICAgIGxldCBpbmRlbnQgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzID0gbGluZS50cmltU3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCA9IGNhcFsyXS5zZWFyY2goL1teIF0vKTsgLy8gRmluZCBmaXJzdCBub24tc3BhY2UgY2hhclxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgPSBpbmRlbnQgPiA0ID8gMSA6IGluZGVudDsgLy8gVHJlYXQgaW5kZW50ZWQgY29kZSBibG9ja3MgKD4gNCBzcGFjZXMpIGFzIGhhdmluZyBvbmx5IDEgaW5kZW50XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyA9IGxpbmUuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9IGNhcFsxXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBibGFua0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmUgJiYgL14gKiQvLnRlc3QobmV4dExpbmUpKSB7IC8vIEl0ZW1zIGJlZ2luIHdpdGggYXQgbW9zdCBvbmUgYmxhbmsgbGluZVxuICAgICAgICAgICAgICAgICAgICByYXcgKz0gbmV4dExpbmUgKyAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhuZXh0TGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kRWFybHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVuZEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRCdWxsZXRSZWdleCA9IG5ldyBSZWdFeHAoYF4gezAsJHtNYXRoLm1pbigzLCBpbmRlbnQgLSAxKX19KD86WyorLV18XFxcXGR7MSw5fVsuKV0pKCg/OlsgXFx0XVteXFxcXG5dKik/KD86XFxcXG58JCkpYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhyUmVnZXggPSBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSgoPzotICopezMsfXwoPzpfICopezMsfXwoPzpcXFxcKiAqKXszLH0pKD86XFxcXG4rfCQpYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZlbmNlc0JlZ2luUmVnZXggPSBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSg/OlxcYFxcYFxcYHx+fn4pYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRpbmdCZWdpblJlZ2V4ID0gbmV3IFJlZ0V4cChgXiB7MCwke01hdGgubWluKDMsIGluZGVudCAtIDEpfX0jYCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGZvbGxvd2luZyBsaW5lcyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gTGlzdCBJdGVtXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd0xpbmUgPSBzcmMuc3BsaXQoJ1xcbicsIDEpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dExpbmUgPSByYXdMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmUtYWxpZ24gdG8gZm9sbG93IGNvbW1vbm1hcmsgbmVzdGluZyBydWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRMaW5lID0gbmV4dExpbmUucmVwbGFjZSgvXiB7MSw0fSg/PSggezR9KSpbXiBdKS9nLCAnICAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuZCBsaXN0IGl0ZW0gaWYgZm91bmQgY29kZSBmZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZW5jZXNCZWdpblJlZ2V4LnRlc3QobmV4dExpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIHN0YXJ0IG9mIG5ldyBoZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGluZ0JlZ2luUmVnZXgudGVzdChuZXh0TGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuZCBsaXN0IGl0ZW0gaWYgZm91bmQgc3RhcnQgb2YgbmV3IGJ1bGxldFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRCdWxsZXRSZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBydWxlIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHJSZWdleC50ZXN0KHNyYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0TGluZS5zZWFyY2goL1teIF0vKSA+PSBpbmRlbnQgfHwgIW5leHRMaW5lLnRyaW0oKSkgeyAvLyBEZWRlbnQgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtQ29udGVudHMgKz0gJ1xcbicgKyBuZXh0TGluZS5zbGljZShpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IGVub3VnaCBpbmRlbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibGFua0xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcmFncmFwaCBjb250aW51YXRpb24gdW5sZXNzIGxhc3QgbGluZSB3YXMgYSBkaWZmZXJlbnQgYmxvY2sgbGV2ZWwgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLnNlYXJjaCgvW14gXS8pID49IDQpIHsgLy8gaW5kZW50ZWQgY29kZSBibG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZlbmNlc0JlZ2luUmVnZXgudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRpbmdCZWdpblJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoclJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyArPSAnXFxuJyArIG5leHRMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFibGFua0xpbmUgJiYgIW5leHRMaW5lLnRyaW0oKSkgeyAvLyBDaGVjayBpZiBjdXJyZW50IGxpbmUgaXMgYmxhbmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3ICs9IHJhd0xpbmUgKyAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcocmF3TGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSBuZXh0TGluZS5zbGljZShpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbGlzdC5sb29zZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgaXRlbSBlbmRlZCB3aXRoIGEgYmxhbmsgbGluZSwgdGhlIGxpc3QgaXMgbG9vc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZHNXaXRoQmxhbmtMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0Lmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvXFxuICpcXG4gKiQvLnRlc3QocmF3KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kc1dpdGhCbGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBpc3Rhc2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBpc2NoZWNrZWQ7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRhc2sgbGlzdCBpdGVtc1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzdGFzayA9IC9eXFxbWyB4WF1cXF0gLy5leGVjKGl0ZW1Db250ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc3Rhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzY2hlY2tlZCA9IGlzdGFza1swXSAhPT0gJ1sgXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzID0gaXRlbUNvbnRlbnRzLnJlcGxhY2UoL15cXFtbIHhYXVxcXSArLywgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpc3QuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaXN0X2l0ZW0nLFxuICAgICAgICAgICAgICAgICAgICByYXcsXG4gICAgICAgICAgICAgICAgICAgIHRhc2s6ICEhaXN0YXNrLFxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiBpc2NoZWNrZWQsXG4gICAgICAgICAgICAgICAgICAgIGxvb3NlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogaXRlbUNvbnRlbnRzLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IFtdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGlzdC5yYXcgKz0gcmF3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG8gbm90IGNvbnN1bWUgbmV3bGluZXMgYXQgZW5kIG9mIGZpbmFsIGl0ZW0uIEFsdGVybmF0aXZlbHksIG1ha2UgaXRlbVJlZ2V4ICpzdGFydCogd2l0aCBhbnkgbmV3bGluZXMgdG8gc2ltcGxpZnkvc3BlZWQgdXAgZW5kc1dpdGhCbGFua0xpbmUgbG9naWNcbiAgICAgICAgICAgIGxpc3QuaXRlbXNbbGlzdC5pdGVtcy5sZW5ndGggLSAxXS5yYXcgPSByYXcudHJpbUVuZCgpO1xuICAgICAgICAgICAgbGlzdC5pdGVtc1tsaXN0Lml0ZW1zLmxlbmd0aCAtIDFdLnRleHQgPSBpdGVtQ29udGVudHMudHJpbUVuZCgpO1xuICAgICAgICAgICAgbGlzdC5yYXcgPSBsaXN0LnJhdy50cmltRW5kKCk7XG4gICAgICAgICAgICAvLyBJdGVtIGNoaWxkIHRva2VucyBoYW5kbGVkIGhlcmUgYXQgZW5kIGJlY2F1c2Ugd2UgbmVlZGVkIHRvIGhhdmUgdGhlIGZpbmFsIGl0ZW0gdG8gdHJpbSBpdCBmaXJzdFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS50b3AgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsaXN0Lml0ZW1zW2ldLnRva2VucyA9IHRoaXMubGV4ZXIuYmxvY2tUb2tlbnMobGlzdC5pdGVtc1tpXS50ZXh0LCBbXSk7XG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGxpc3Qgc2hvdWxkIGJlIGxvb3NlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwYWNlcnMgPSBsaXN0Lml0ZW1zW2ldLnRva2Vucy5maWx0ZXIodCA9PiB0LnR5cGUgPT09ICdzcGFjZScpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNNdWx0aXBsZUxpbmVCcmVha3MgPSBzcGFjZXJzLmxlbmd0aCA+IDAgJiYgc3BhY2Vycy5zb21lKHQgPT4gL1xcbi4qXFxuLy50ZXN0KHQucmF3KSk7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QubG9vc2UgPSBoYXNNdWx0aXBsZUxpbmVCcmVha3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IGFsbCBpdGVtcyB0byBsb29zZSBpZiBsaXN0IGlzIGxvb3NlXG4gICAgICAgICAgICBpZiAobGlzdC5sb29zZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsaXN0Lml0ZW1zW2ldLmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBodG1sKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmh0bWwuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaHRtbCcsXG4gICAgICAgICAgICAgICAgYmxvY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgcHJlOiBjYXBbMV0gPT09ICdwcmUnIHx8IGNhcFsxXSA9PT0gJ3NjcmlwdCcgfHwgY2FwWzFdID09PSAnc3R5bGUnLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWYoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suZGVmLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gY2FwWzFdLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgICAgICAgY29uc3QgaHJlZiA9IGNhcFsyXSA/IGNhcFsyXS5yZXBsYWNlKC9ePCguKik+JC8sICckMScpLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogJyc7XG4gICAgICAgICAgICBjb25zdCB0aXRsZSA9IGNhcFszXSA/IGNhcFszXS5zdWJzdHJpbmcoMSwgY2FwWzNdLmxlbmd0aCAtIDEpLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogY2FwWzNdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZGVmJyxcbiAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgICAgICB0aXRsZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0YWJsZShzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay50YWJsZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGlmICghL1s6fF0vLnRlc3QoY2FwWzJdKSkge1xuICAgICAgICAgICAgICAgIC8vIGRlbGltaXRlciByb3cgbXVzdCBoYXZlIGEgcGlwZSAofCkgb3IgY29sb24gKDopIG90aGVyd2lzZSBpdCBpcyBhIHNldGV4dCBoZWFkaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIGhlYWRlcjogc3BsaXRDZWxscyhjYXBbMV0pLm1hcChjID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogYywgdG9rZW5zOiBbXSB9O1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXlxcfHxcXHwgKiQvZywgJycpLnNwbGl0KCd8JyksXG4gICAgICAgICAgICAgICAgcm93czogY2FwWzNdICYmIGNhcFszXS50cmltKCkgPyBjYXBbM10ucmVwbGFjZSgvXFxuWyBcXHRdKiQvLCAnJykuc3BsaXQoJ1xcbicpIDogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaXRlbS5oZWFkZXIubGVuZ3RoID09PSBpdGVtLmFsaWduLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBsID0gaXRlbS5hbGlnbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGksIGosIGssIHJvdztcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsaWduID0gaXRlbS5hbGlnbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChhbGlnbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGFsaWduKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9eICo6LSsgKiQvLnRlc3QoYWxpZ24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGwgPSBpdGVtLnJvd3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5yb3dzW2ldID0gc3BsaXRDZWxscyhpdGVtLnJvd3NbaV0sIGl0ZW0uaGVhZGVyLmxlbmd0aCkubWFwKGMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogYywgdG9rZW5zOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcGFyc2UgY2hpbGQgdG9rZW5zIGluc2lkZSBoZWFkZXJzIGFuZCBjZWxsc1xuICAgICAgICAgICAgICAgIC8vIGhlYWRlciBjaGlsZCB0b2tlbnNcbiAgICAgICAgICAgICAgICBsID0gaXRlbS5oZWFkZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5oZWFkZXJbal0udG9rZW5zID0gdGhpcy5sZXhlci5pbmxpbmUoaXRlbS5oZWFkZXJbal0udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNlbGwgY2hpbGQgdG9rZW5zXG4gICAgICAgICAgICAgICAgbCA9IGl0ZW0ucm93cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGw7IGorKykge1xuICAgICAgICAgICAgICAgICAgICByb3cgPSBpdGVtLnJvd3Nbal07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCByb3cubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd1trXS50b2tlbnMgPSB0aGlzLmxleGVyLmlubGluZShyb3dba10udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGhlYWRpbmcoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2subGhlYWRpbmcuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICBkZXB0aDogY2FwWzJdLmNoYXJBdCgwKSA9PT0gJz0nID8gMSA6IDIsXG4gICAgICAgICAgICAgICAgdGV4dDogY2FwWzFdLFxuICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmUoY2FwWzFdKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJhZ3JhcGgoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2sucGFyYWdyYXBoLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGNhcFsxXS5jaGFyQXQoY2FwWzFdLmxlbmd0aCAtIDEpID09PSAnXFxuJ1xuICAgICAgICAgICAgICAgID8gY2FwWzFdLnNsaWNlKDAsIC0xKVxuICAgICAgICAgICAgICAgIDogY2FwWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmUodGV4dClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGV4dChzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay50ZXh0LmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dDogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmUoY2FwWzBdKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlc2NhcGUoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmVzY2FwZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2VzY2FwZScsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dDogZXNjYXBlKGNhcFsxXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGFnKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS50YWcuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rICYmIC9ePGEgL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgJiYgL148XFwvYT4vaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluTGluayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgJiYgL148KHByZXxjb2RlfGtiZHxzY3JpcHQpKFxcc3w+KS9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgJiYgL148XFwvKHByZXxjb2RlfGtiZHxzY3JpcHQpKFxcc3w+KS9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaHRtbCcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgaW5MaW5rOiB0aGlzLmxleGVyLnN0YXRlLmluTGluayxcbiAgICAgICAgICAgICAgICBpblJhd0Jsb2NrOiB0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2ssXG4gICAgICAgICAgICAgICAgYmxvY2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsaW5rKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5saW5rLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgdHJpbW1lZFVybCA9IGNhcFsyXS50cmltKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5wZWRhbnRpYyAmJiAvXjwvLnRlc3QodHJpbW1lZFVybCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb21tb25tYXJrIHJlcXVpcmVzIG1hdGNoaW5nIGFuZ2xlIGJyYWNrZXRzXG4gICAgICAgICAgICAgICAgaWYgKCEoLz4kLy50ZXN0KHRyaW1tZWRVcmwpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVuZGluZyBhbmdsZSBicmFja2V0IGNhbm5vdCBiZSBlc2NhcGVkXG4gICAgICAgICAgICAgICAgY29uc3QgcnRyaW1TbGFzaCA9IHJ0cmltKHRyaW1tZWRVcmwuc2xpY2UoMCwgLTEpLCAnXFxcXCcpO1xuICAgICAgICAgICAgICAgIGlmICgodHJpbW1lZFVybC5sZW5ndGggLSBydHJpbVNsYXNoLmxlbmd0aCkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIGNsb3NpbmcgcGFyZW50aGVzaXNcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0UGFyZW5JbmRleCA9IGZpbmRDbG9zaW5nQnJhY2tldChjYXBbMl0sICcoKScpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UGFyZW5JbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gY2FwWzBdLmluZGV4T2YoJyEnKSA9PT0gMCA/IDUgOiA0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rTGVuID0gc3RhcnQgKyBjYXBbMV0ubGVuZ3RoICsgbGFzdFBhcmVuSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGNhcFsyXSA9IGNhcFsyXS5zdWJzdHJpbmcoMCwgbGFzdFBhcmVuSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBjYXBbMF0gPSBjYXBbMF0uc3Vic3RyaW5nKDAsIGxpbmtMZW4pLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgY2FwWzNdID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGhyZWYgPSBjYXBbMl07XG4gICAgICAgICAgICBsZXQgdGl0bGUgPSAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCBwZWRhbnRpYyBocmVmIGFuZCB0aXRsZVxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSAvXihbXidcIl0qW15cXHNdKVxccysoWydcIl0pKC4qKVxcMi8uZXhlYyhocmVmKTtcbiAgICAgICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gbGlua1sxXTtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSBsaW5rWzNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpdGxlID0gY2FwWzNdID8gY2FwWzNdLnNsaWNlKDEsIC0xKSA6ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHJlZiA9IGhyZWYudHJpbSgpO1xuICAgICAgICAgICAgaWYgKC9ePC8udGVzdChocmVmKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMgJiYgISgvPiQvLnRlc3QodHJpbW1lZFVybCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBlZGFudGljIGFsbG93cyBzdGFydGluZyBhbmdsZSBicmFja2V0IHdpdGhvdXQgZW5kaW5nIGFuZ2xlIGJyYWNrZXRcbiAgICAgICAgICAgICAgICAgICAgaHJlZiA9IGhyZWYuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gaHJlZi5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dExpbmsoY2FwLCB7XG4gICAgICAgICAgICAgICAgaHJlZjogaHJlZiA/IGhyZWYucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5fZXNjYXBlcywgJyQxJykgOiBocmVmLFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSA/IHRpdGxlLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogdGl0bGVcbiAgICAgICAgICAgIH0sIGNhcFswXSwgdGhpcy5sZXhlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmbGluayhzcmMsIGxpbmtzKSB7XG4gICAgICAgIGxldCBjYXA7XG4gICAgICAgIGlmICgoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUucmVmbGluay5leGVjKHNyYykpXG4gICAgICAgICAgICB8fCAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUubm9saW5rLmV4ZWMoc3JjKSkpIHtcbiAgICAgICAgICAgIGxldCBsaW5rID0gKGNhcFsyXSB8fCBjYXBbMV0pLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgICAgICAgIGxpbmsgPSBsaW5rc1tsaW5rLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGNhcFswXS5jaGFyQXQoMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICByYXc6IHRleHQsXG4gICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dExpbmsoY2FwLCBsaW5rLCBjYXBbMF0sIHRoaXMubGV4ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVtU3Ryb25nKHNyYywgbWFza2VkU3JjLCBwcmV2Q2hhciA9ICcnKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IHRoaXMucnVsZXMuaW5saW5lLmVtU3Ryb25nLmxEZWxpbS5leGVjKHNyYyk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIF8gY2FuJ3QgYmUgYmV0d2VlbiB0d28gYWxwaGFudW1lcmljcy4gXFxwe0x9XFxwe059IGluY2x1ZGVzIG5vbi1lbmdsaXNoIGFscGhhYmV0L251bWJlcnMgYXMgd2VsbFxuICAgICAgICBpZiAobWF0Y2hbM10gJiYgcHJldkNoYXIubWF0Y2goL1tcXHB7TH1cXHB7Tn1dL3UpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBuZXh0Q2hhciA9IG1hdGNoWzFdIHx8IG1hdGNoWzJdIHx8ICcnO1xuICAgICAgICBpZiAoIW5leHRDaGFyIHx8ICFwcmV2Q2hhciB8fCB0aGlzLnJ1bGVzLmlubGluZS5wdW5jdHVhdGlvbi5leGVjKHByZXZDaGFyKSkge1xuICAgICAgICAgICAgLy8gdW5pY29kZSBSZWdleCBjb3VudHMgZW1vamkgYXMgMSBjaGFyOyBzcHJlYWQgaW50byBhcnJheSBmb3IgcHJvcGVyIGNvdW50ICh1c2VkIG11bHRpcGxlIHRpbWVzIGJlbG93KVxuICAgICAgICAgICAgY29uc3QgbExlbmd0aCA9IFsuLi5tYXRjaFswXV0ubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGxldCByRGVsaW0sIHJMZW5ndGgsIGRlbGltVG90YWwgPSBsTGVuZ3RoLCBtaWREZWxpbVRvdGFsID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGVuZFJlZyA9IG1hdGNoWzBdWzBdID09PSAnKicgPyB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZy5yRGVsaW1Bc3QgOiB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZy5yRGVsaW1VbmQ7XG4gICAgICAgICAgICBlbmRSZWcubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIC8vIENsaXAgbWFza2VkU3JjIHRvIHNhbWUgc2VjdGlvbiBvZiBzdHJpbmcgYXMgc3JjIChtb3ZlIHRvIGxleGVyPylcbiAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgtMSAqIHNyYy5sZW5ndGggKyBsTGVuZ3RoKTtcbiAgICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBlbmRSZWcuZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgckRlbGltID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl0gfHwgbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgbWF0Y2hbNl07XG4gICAgICAgICAgICAgICAgaWYgKCFyRGVsaW0pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBza2lwIHNpbmdsZSAqIGluIF9fYWJjKmFiY19fXG4gICAgICAgICAgICAgICAgckxlbmd0aCA9IFsuLi5yRGVsaW1dLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbM10gfHwgbWF0Y2hbNF0pIHsgLy8gZm91bmQgYW5vdGhlciBMZWZ0IERlbGltXG4gICAgICAgICAgICAgICAgICAgIGRlbGltVG90YWwgKz0gckxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoWzVdIHx8IG1hdGNoWzZdKSB7IC8vIGVpdGhlciBMZWZ0IG9yIFJpZ2h0IERlbGltXG4gICAgICAgICAgICAgICAgICAgIGlmIChsTGVuZ3RoICUgMyAmJiAhKChsTGVuZ3RoICsgckxlbmd0aCkgJSAzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlkRGVsaW1Ub3RhbCArPSByTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIENvbW1vbk1hcmsgRW1waGFzaXMgUnVsZXMgOS0xMFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGltVG90YWwgLT0gckxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoZGVsaW1Ub3RhbCA+IDApXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBIYXZlbid0IGZvdW5kIGVub3VnaCBjbG9zaW5nIGRlbGltaXRlcnNcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZXh0cmEgY2hhcmFjdGVycy4gKmEqKiogLT4gKmEqXG4gICAgICAgICAgICAgICAgckxlbmd0aCA9IE1hdGgubWluKHJMZW5ndGgsIHJMZW5ndGggKyBkZWxpbVRvdGFsICsgbWlkRGVsaW1Ub3RhbCk7XG4gICAgICAgICAgICAgICAgLy8gY2hhciBsZW5ndGggY2FuIGJlID4xIGZvciB1bmljb2RlIGNoYXJhY3RlcnM7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdENoYXJMZW5ndGggPSBbLi4ubWF0Y2hbMF1dWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCByYXcgPSBzcmMuc2xpY2UoMCwgbExlbmd0aCArIG1hdGNoLmluZGV4ICsgbGFzdENoYXJMZW5ndGggKyByTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYGVtYCBpZiBzbWFsbGVzdCBkZWxpbWl0ZXIgaGFzIG9kZCBjaGFyIGNvdW50LiAqYSoqKlxuICAgICAgICAgICAgICAgIGlmIChNYXRoLm1pbihsTGVuZ3RoLCByTGVuZ3RoKSAlIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IHJhdy5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnModGV4dClcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlICdzdHJvbmcnIGlmIHNtYWxsZXN0IGRlbGltaXRlciBoYXMgZXZlbiBjaGFyIGNvdW50LiAqKmEqKipcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gcmF3LnNsaWNlKDIsIC0yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3Ryb25nJyxcbiAgICAgICAgICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lVG9rZW5zKHRleHQpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb2Rlc3BhbihzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuY29kZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gY2FwWzJdLnJlcGxhY2UoL1xcbi9nLCAnICcpO1xuICAgICAgICAgICAgY29uc3QgaGFzTm9uU3BhY2VDaGFycyA9IC9bXiBdLy50ZXN0KHRleHQpO1xuICAgICAgICAgICAgY29uc3QgaGFzU3BhY2VDaGFyc09uQm90aEVuZHMgPSAvXiAvLnRlc3QodGV4dCkgJiYgLyAkLy50ZXN0KHRleHQpO1xuICAgICAgICAgICAgaWYgKGhhc05vblNwYWNlQ2hhcnMgJiYgaGFzU3BhY2VDaGFyc09uQm90aEVuZHMpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMSwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQgPSBlc2NhcGUodGV4dCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb2Rlc3BhbicsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBicihzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuYnIuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdicicsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVsKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5kZWwuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdkZWwnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNhcFsyXSxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lVG9rZW5zKGNhcFsyXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXV0b2xpbmsoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmF1dG9saW5rLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IHRleHQsIGhyZWY7XG4gICAgICAgICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZXNjYXBlKGNhcFsxXSk7XG4gICAgICAgICAgICAgICAgaHJlZiA9ICdtYWlsdG86JyArIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZXNjYXBlKGNhcFsxXSk7XG4gICAgICAgICAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICAgICAgdG9rZW5zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXJsKHNyYykge1xuICAgICAgICBsZXQgY2FwO1xuICAgICAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudXJsLmV4ZWMoc3JjKSkge1xuICAgICAgICAgICAgbGV0IHRleHQsIGhyZWY7XG4gICAgICAgICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZXNjYXBlKGNhcFswXSk7XG4gICAgICAgICAgICAgICAgaHJlZiA9ICdtYWlsdG86JyArIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkbyBleHRlbmRlZCBhdXRvbGluayBwYXRoIHZhbGlkYXRpb25cbiAgICAgICAgICAgICAgICBsZXQgcHJldkNhcFplcm87XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBwcmV2Q2FwWmVybyA9IGNhcFswXTtcbiAgICAgICAgICAgICAgICAgICAgY2FwWzBdID0gdGhpcy5ydWxlcy5pbmxpbmUuX2JhY2twZWRhbC5leGVjKGNhcFswXSlbMF07XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAocHJldkNhcFplcm8gIT09IGNhcFswXSk7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMF0pO1xuICAgICAgICAgICAgICAgIGlmIChjYXBbMV0gPT09ICd3d3cuJykge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gJ2h0dHA6Ly8nICsgY2FwWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZiA9IGNhcFswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICAgICAgdG9rZW5zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5saW5lVGV4dChzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudGV4dC5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGxldCB0ZXh0O1xuICAgICAgICAgICAgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jaykge1xuICAgICAgICAgICAgICAgIHRleHQgPSBjYXBbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZXNjYXBlKGNhcFswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEJsb2NrLUxldmVsIEdyYW1tYXJcbiAqL1xuLy8gTm90IGFsbCBydWxlcyBhcmUgZGVmaW5lZCBpbiB0aGUgb2JqZWN0IGxpdGVyYWxcbi8vIEB0cy1leHBlY3QtZXJyb3JcbmNvbnN0IGJsb2NrID0ge1xuICAgIG5ld2xpbmU6IC9eKD86ICooPzpcXG58JCkpKy8sXG4gICAgY29kZTogL14oIHs0fVteXFxuXSsoPzpcXG4oPzogKig/OlxcbnwkKSkqKT8pKy8sXG4gICAgZmVuY2VzOiAvXiB7MCwzfShgezMsfSg/PVteYFxcbl0qKD86XFxufCQpKXx+ezMsfSkoW15cXG5dKikoPzpcXG58JCkoPzp8KFtcXHNcXFNdKj8pKD86XFxufCQpKSg/OiB7MCwzfVxcMVt+YF0qICooPz1cXG58JCl8JCkvLFxuICAgIGhyOiAvXiB7MCwzfSgoPzotW1xcdCBdKil7Myx9fCg/Ol9bIFxcdF0qKXszLH18KD86XFwqWyBcXHRdKil7Myx9KSg/Olxcbit8JCkvLFxuICAgIGhlYWRpbmc6IC9eIHswLDN9KCN7MSw2fSkoPz1cXHN8JCkoLiopKD86XFxuK3wkKS8sXG4gICAgYmxvY2txdW90ZTogL14oIHswLDN9PiA/KHBhcmFncmFwaHxbXlxcbl0qKSg/OlxcbnwkKSkrLyxcbiAgICBsaXN0OiAvXiggezAsM31idWxsKShbIFxcdF1bXlxcbl0rPyk/KD86XFxufCQpLyxcbiAgICBodG1sOiAnXiB7MCwzfSg/OicgLy8gb3B0aW9uYWwgaW5kZW50YXRpb25cbiAgICAgICAgKyAnPChzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKVtcXFxccz5dW1xcXFxzXFxcXFNdKj8oPzo8L1xcXFwxPlteXFxcXG5dKlxcXFxuK3wkKScgLy8gKDEpXG4gICAgICAgICsgJ3xjb21tZW50W15cXFxcbl0qKFxcXFxuK3wkKScgLy8gKDIpXG4gICAgICAgICsgJ3w8XFxcXD9bXFxcXHNcXFxcU10qPyg/OlxcXFw/PlxcXFxuKnwkKScgLy8gKDMpXG4gICAgICAgICsgJ3w8IVtBLVpdW1xcXFxzXFxcXFNdKj8oPzo+XFxcXG4qfCQpJyAvLyAoNClcbiAgICAgICAgKyAnfDwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj8oPzpcXFxcXVxcXFxdPlxcXFxuKnwkKScgLy8gKDUpXG4gICAgICAgICsgJ3w8Lz8odGFnKSg/OiArfFxcXFxufC8/PilbXFxcXHNcXFxcU10qPyg/Oig/OlxcXFxuICopK1xcXFxufCQpJyAvLyAoNilcbiAgICAgICAgKyAnfDwoPyFzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKShbYS16XVtcXFxcdy1dKikoPzphdHRyaWJ1dGUpKj8gKi8/Pig/PVsgXFxcXHRdKig/OlxcXFxufCQpKVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG4gKikrXFxcXG58JCknIC8vICg3KSBvcGVuIHRhZ1xuICAgICAgICArICd8PC8oPyFzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKVthLXpdW1xcXFx3LV0qXFxcXHMqPig/PVsgXFxcXHRdKig/OlxcXFxufCQpKVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG4gKikrXFxcXG58JCknIC8vICg3KSBjbG9zaW5nIHRhZ1xuICAgICAgICArICcpJyxcbiAgICBkZWY6IC9eIHswLDN9XFxbKGxhYmVsKVxcXTogKig/OlxcbiAqKT8oW148XFxzXVteXFxzXSp8PC4qPz4pKD86KD86ICsoPzpcXG4gKik/fCAqXFxuICopKHRpdGxlKSk/ICooPzpcXG4rfCQpLyxcbiAgICB0YWJsZTogbm9vcFRlc3QsXG4gICAgbGhlYWRpbmc6IC9eKD8hYnVsbCApKCg/Oi58XFxuKD8hXFxzKj9cXG58YnVsbCApKSs/KVxcbiB7MCwzfSg9K3wtKykgKig/Olxcbit8JCkvLFxuICAgIC8vIHJlZ2V4IHRlbXBsYXRlLCBwbGFjZWhvbGRlcnMgd2lsbCBiZSByZXBsYWNlZCBhY2NvcmRpbmcgdG8gZGlmZmVyZW50IHBhcmFncmFwaFxuICAgIC8vIGludGVycnVwdGlvbiBydWxlcyBvZiBjb21tb25tYXJrIGFuZCB0aGUgb3JpZ2luYWwgbWFya2Rvd24gc3BlYzpcbiAgICBfcGFyYWdyYXBoOiAvXihbXlxcbl0rKD86XFxuKD8haHJ8aGVhZGluZ3xsaGVhZGluZ3xibG9ja3F1b3RlfGZlbmNlc3xsaXN0fGh0bWx8dGFibGV8ICtcXG4pW15cXG5dKykqKS8sXG4gICAgdGV4dDogL15bXlxcbl0rL1xufTtcbmJsb2NrLl9sYWJlbCA9IC8oPyFcXHMqXFxdKSg/OlxcXFwufFteXFxbXFxdXFxcXF0pKy87XG5ibG9jay5fdGl0bGUgPSAvKD86XCIoPzpcXFxcXCI/fFteXCJcXFxcXSkqXCJ8J1teJ1xcbl0qKD86XFxuW14nXFxuXSspKlxcbj8nfFxcKFteKCldKlxcKSkvO1xuYmxvY2suZGVmID0gZWRpdChibG9jay5kZWYpXG4gICAgLnJlcGxhY2UoJ2xhYmVsJywgYmxvY2suX2xhYmVsKVxuICAgIC5yZXBsYWNlKCd0aXRsZScsIGJsb2NrLl90aXRsZSlcbiAgICAuZ2V0UmVnZXgoKTtcbmJsb2NrLmJ1bGxldCA9IC8oPzpbKistXXxcXGR7MSw5fVsuKV0pLztcbmJsb2NrLmxpc3RJdGVtU3RhcnQgPSBlZGl0KC9eKCAqKShidWxsKSAqLylcbiAgICAucmVwbGFjZSgnYnVsbCcsIGJsb2NrLmJ1bGxldClcbiAgICAuZ2V0UmVnZXgoKTtcbmJsb2NrLmxpc3QgPSBlZGl0KGJsb2NrLmxpc3QpXG4gICAgLnJlcGxhY2UoL2J1bGwvZywgYmxvY2suYnVsbGV0KVxuICAgIC5yZXBsYWNlKCdocicsICdcXFxcbisoPz1cXFxcMT8oPzooPzotICopezMsfXwoPzpfICopezMsfXwoPzpcXFxcKiAqKXszLH0pKD86XFxcXG4rfCQpKScpXG4gICAgLnJlcGxhY2UoJ2RlZicsICdcXFxcbisoPz0nICsgYmxvY2suZGVmLnNvdXJjZSArICcpJylcbiAgICAuZ2V0UmVnZXgoKTtcbmJsb2NrLl90YWcgPSAnYWRkcmVzc3xhcnRpY2xlfGFzaWRlfGJhc2V8YmFzZWZvbnR8YmxvY2txdW90ZXxib2R5fGNhcHRpb24nXG4gICAgKyAnfGNlbnRlcnxjb2x8Y29sZ3JvdXB8ZGR8ZGV0YWlsc3xkaWFsb2d8ZGlyfGRpdnxkbHxkdHxmaWVsZHNldHxmaWdjYXB0aW9uJ1xuICAgICsgJ3xmaWd1cmV8Zm9vdGVyfGZvcm18ZnJhbWV8ZnJhbWVzZXR8aFsxLTZdfGhlYWR8aGVhZGVyfGhyfGh0bWx8aWZyYW1lJ1xuICAgICsgJ3xsZWdlbmR8bGl8bGlua3xtYWlufG1lbnV8bWVudWl0ZW18bWV0YXxuYXZ8bm9mcmFtZXN8b2x8b3B0Z3JvdXB8b3B0aW9uJ1xuICAgICsgJ3xwfHBhcmFtfHNlY3Rpb258c291cmNlfHN1bW1hcnl8dGFibGV8dGJvZHl8dGR8dGZvb3R8dGh8dGhlYWR8dGl0bGV8dHInXG4gICAgKyAnfHRyYWNrfHVsJztcbmJsb2NrLl9jb21tZW50ID0gLzwhLS0oPyEtPz4pW1xcc1xcU10qPyg/Oi0tPnwkKS87XG5ibG9jay5odG1sID0gZWRpdChibG9jay5odG1sLCAnaScpXG4gICAgLnJlcGxhY2UoJ2NvbW1lbnQnLCBibG9jay5fY29tbWVudClcbiAgICAucmVwbGFjZSgndGFnJywgYmxvY2suX3RhZylcbiAgICAucmVwbGFjZSgnYXR0cmlidXRlJywgLyArW2EtekEtWjpfXVtcXHcuOi1dKig/OiAqPSAqXCJbXlwiXFxuXSpcInwgKj0gKidbXidcXG5dKid8ICo9ICpbXlxcc1wiJz08PmBdKyk/LylcbiAgICAuZ2V0UmVnZXgoKTtcbmJsb2NrLmxoZWFkaW5nID0gZWRpdChibG9jay5saGVhZGluZylcbiAgICAucmVwbGFjZSgvYnVsbC9nLCBibG9jay5idWxsZXQpIC8vIGxpc3RzIGNhbiBpbnRlcnJ1cHRcbiAgICAuZ2V0UmVnZXgoKTtcbmJsb2NrLnBhcmFncmFwaCA9IGVkaXQoYmxvY2suX3BhcmFncmFwaClcbiAgICAucmVwbGFjZSgnaHInLCBibG9jay5ocilcbiAgICAucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0oPzpcXFxcc3wkKScpXG4gICAgLnJlcGxhY2UoJ3xsaGVhZGluZycsICcnKSAvLyBzZXRleCBoZWFkaW5ncyBkb24ndCBpbnRlcnJ1cHQgY29tbW9ubWFyayBwYXJhZ3JhcGhzXG4gICAgLnJlcGxhY2UoJ3x0YWJsZScsICcnKVxuICAgIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKVxuICAgIC5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJylcbiAgICAucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAgIC5yZXBsYWNlKCdodG1sJywgJzwvPyg/OnRhZykoPzogK3xcXFxcbnwvPz4pfDwoPzpzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhfCEtLSknKVxuICAgIC5yZXBsYWNlKCd0YWcnLCBibG9jay5fdGFnKSAvLyBwYXJzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAgIC5nZXRSZWdleCgpO1xuYmxvY2suYmxvY2txdW90ZSA9IGVkaXQoYmxvY2suYmxvY2txdW90ZSlcbiAgICAucmVwbGFjZSgncGFyYWdyYXBoJywgYmxvY2sucGFyYWdyYXBoKVxuICAgIC5nZXRSZWdleCgpO1xuLyoqXG4gKiBOb3JtYWwgQmxvY2sgR3JhbW1hclxuICovXG5ibG9jay5ub3JtYWwgPSB7IC4uLmJsb2NrIH07XG4vKipcbiAqIEdGTSBCbG9jayBHcmFtbWFyXG4gKi9cbmJsb2NrLmdmbSA9IHtcbiAgICAuLi5ibG9jay5ub3JtYWwsXG4gICAgdGFibGU6ICdeICooW15cXFxcbiBdLiopXFxcXG4nIC8vIEhlYWRlclxuICAgICAgICArICcgezAsM30oKD86XFxcXHwgKik/Oj8tKzo/ICooPzpcXFxcfCAqOj8tKzo/ICopKig/OlxcXFx8ICopPyknIC8vIEFsaWduXG4gICAgICAgICsgJyg/OlxcXFxuKCg/Oig/ISAqXFxcXG58aHJ8aGVhZGluZ3xibG9ja3F1b3RlfGNvZGV8ZmVuY2VzfGxpc3R8aHRtbCkuKig/OlxcXFxufCQpKSopXFxcXG4qfCQpJyAvLyBDZWxsc1xufTtcbmJsb2NrLmdmbS50YWJsZSA9IGVkaXQoYmxvY2suZ2ZtLnRhYmxlKVxuICAgIC5yZXBsYWNlKCdocicsIGJsb2NrLmhyKVxuICAgIC5yZXBsYWNlKCdoZWFkaW5nJywgJyB7MCwzfSN7MSw2fSg/OlxcXFxzfCQpJylcbiAgICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgICAucmVwbGFjZSgnY29kZScsICcgezR9W15cXFxcbl0nKVxuICAgIC5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJylcbiAgICAucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAgIC5yZXBsYWNlKCdodG1sJywgJzwvPyg/OnRhZykoPzogK3xcXFxcbnwvPz4pfDwoPzpzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhfCEtLSknKVxuICAgIC5yZXBsYWNlKCd0YWcnLCBibG9jay5fdGFnKSAvLyB0YWJsZXMgY2FuIGJlIGludGVycnVwdGVkIGJ5IHR5cGUgKDYpIGh0bWwgYmxvY2tzXG4gICAgLmdldFJlZ2V4KCk7XG5ibG9jay5nZm0ucGFyYWdyYXBoID0gZWRpdChibG9jay5fcGFyYWdyYXBoKVxuICAgIC5yZXBsYWNlKCdocicsIGJsb2NrLmhyKVxuICAgIC5yZXBsYWNlKCdoZWFkaW5nJywgJyB7MCwzfSN7MSw2fSg/OlxcXFxzfCQpJylcbiAgICAucmVwbGFjZSgnfGxoZWFkaW5nJywgJycpIC8vIHNldGV4IGhlYWRpbmdzIGRvbid0IGludGVycnVwdCBjb21tb25tYXJrIHBhcmFncmFwaHNcbiAgICAucmVwbGFjZSgndGFibGUnLCBibG9jay5nZm0udGFibGUpIC8vIGludGVycnVwdCBwYXJhZ3JhcGhzIHdpdGggdGFibGVcbiAgICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgICAucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpXG4gICAgLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYXwhLS0pJylcbiAgICAucmVwbGFjZSgndGFnJywgYmxvY2suX3RhZykgLy8gcGFycyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3NcbiAgICAuZ2V0UmVnZXgoKTtcbi8qKlxuICogUGVkYW50aWMgZ3JhbW1hciAob3JpZ2luYWwgSm9obiBHcnViZXIncyBsb29zZSBtYXJrZG93biBzcGVjaWZpY2F0aW9uKVxuICovXG5ibG9jay5wZWRhbnRpYyA9IHtcbiAgICAuLi5ibG9jay5ub3JtYWwsXG4gICAgaHRtbDogZWRpdCgnXiAqKD86Y29tbWVudCAqKD86XFxcXG58XFxcXHMqJCknXG4gICAgICAgICsgJ3w8KHRhZylbXFxcXHNcXFxcU10rPzwvXFxcXDE+ICooPzpcXFxcbnsyLH18XFxcXHMqJCknIC8vIGNsb3NlZCB0YWdcbiAgICAgICAgKyAnfDx0YWcoPzpcIlteXCJdKlwifFxcJ1teXFwnXSpcXCd8XFxcXHNbXlxcJ1wiLz5cXFxcc10qKSo/Lz8+ICooPzpcXFxcbnsyLH18XFxcXHMqJCkpJylcbiAgICAgICAgLnJlcGxhY2UoJ2NvbW1lbnQnLCBibG9jay5fY29tbWVudClcbiAgICAgICAgLnJlcGxhY2UoL3RhZy9nLCAnKD8hKD86J1xuICAgICAgICArICdhfGVtfHN0cm9uZ3xzbWFsbHxzfGNpdGV8cXxkZm58YWJicnxkYXRhfHRpbWV8Y29kZXx2YXJ8c2FtcHxrYmR8c3ViJ1xuICAgICAgICArICd8c3VwfGl8Ynx1fG1hcmt8cnVieXxydHxycHxiZGl8YmRvfHNwYW58YnJ8d2JyfGluc3xkZWx8aW1nKSdcbiAgICAgICAgKyAnXFxcXGIpXFxcXHcrKD8hOnxbXlxcXFx3XFxcXHNAXSpAKVxcXFxiJylcbiAgICAgICAgLmdldFJlZ2V4KCksXG4gICAgZGVmOiAvXiAqXFxbKFteXFxdXSspXFxdOiAqPD8oW15cXHM+XSspPj8oPzogKyhbXCIoXVteXFxuXStbXCIpXSkpPyAqKD86XFxuK3wkKS8sXG4gICAgaGVhZGluZzogL14oI3sxLDZ9KSguKikoPzpcXG4rfCQpLyxcbiAgICBmZW5jZXM6IG5vb3BUZXN0LFxuICAgIGxoZWFkaW5nOiAvXiguKz8pXFxuIHswLDN9KD0rfC0rKSAqKD86XFxuK3wkKS8sXG4gICAgcGFyYWdyYXBoOiBlZGl0KGJsb2NrLm5vcm1hbC5fcGFyYWdyYXBoKVxuICAgICAgICAucmVwbGFjZSgnaHInLCBibG9jay5ocilcbiAgICAgICAgLnJlcGxhY2UoJ2hlYWRpbmcnLCAnICojezEsNn0gKlteXFxuXScpXG4gICAgICAgIC5yZXBsYWNlKCdsaGVhZGluZycsIGJsb2NrLmxoZWFkaW5nKVxuICAgICAgICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgICAgICAgLnJlcGxhY2UoJ3xmZW5jZXMnLCAnJylcbiAgICAgICAgLnJlcGxhY2UoJ3xsaXN0JywgJycpXG4gICAgICAgIC5yZXBsYWNlKCd8aHRtbCcsICcnKVxuICAgICAgICAuZ2V0UmVnZXgoKVxufTtcbi8qKlxuICogSW5saW5lLUxldmVsIEdyYW1tYXJcbiAqL1xuLy8gTm90IGFsbCBydWxlcyBhcmUgZGVmaW5lZCBpbiB0aGUgb2JqZWN0IGxpdGVyYWxcbi8vIEB0cy1leHBlY3QtZXJyb3JcbmNvbnN0IGlubGluZSA9IHtcbiAgICBlc2NhcGU6IC9eXFxcXChbIVwiIyQlJicoKSorLFxcLS4vOjs8PT4/QFxcW1xcXVxcXFxeX2B7fH1+XSkvLFxuICAgIGF1dG9saW5rOiAvXjwoc2NoZW1lOlteXFxzXFx4MDAtXFx4MWY8Pl0qfGVtYWlsKT4vLFxuICAgIHVybDogbm9vcFRlc3QsXG4gICAgdGFnOiAnXmNvbW1lbnQnXG4gICAgICAgICsgJ3xePC9bYS16QS1aXVtcXFxcdzotXSpcXFxccyo+JyAvLyBzZWxmLWNsb3NpbmcgdGFnXG4gICAgICAgICsgJ3xePFthLXpBLVpdW1xcXFx3LV0qKD86YXR0cmlidXRlKSo/XFxcXHMqLz8+JyAvLyBvcGVuIHRhZ1xuICAgICAgICArICd8XjxcXFxcP1tcXFxcc1xcXFxTXSo/XFxcXD8+JyAvLyBwcm9jZXNzaW5nIGluc3RydWN0aW9uLCBlLmcuIDw/cGhwID8+XG4gICAgICAgICsgJ3xePCFbYS16QS1aXStcXFxcc1tcXFxcc1xcXFxTXSo/PicgLy8gZGVjbGFyYXRpb24sIGUuZy4gPCFET0NUWVBFIGh0bWw+XG4gICAgICAgICsgJ3xePCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+JyxcbiAgICBsaW5rOiAvXiE/XFxbKGxhYmVsKVxcXVxcKFxccyooaHJlZikoPzpcXHMrKHRpdGxlKSk/XFxzKlxcKS8sXG4gICAgcmVmbGluazogL14hP1xcWyhsYWJlbClcXF1cXFsocmVmKVxcXS8sXG4gICAgbm9saW5rOiAvXiE/XFxbKHJlZilcXF0oPzpcXFtcXF0pPy8sXG4gICAgcmVmbGlua1NlYXJjaDogJ3JlZmxpbmt8bm9saW5rKD8hXFxcXCgpJyxcbiAgICBlbVN0cm9uZzoge1xuICAgICAgICBsRGVsaW06IC9eKD86XFwqKyg/OigoPyFcXCopW3B1bmN0XSl8W15cXHMqXSkpfF5fKyg/OigoPyFfKVtwdW5jdF0pfChbXlxcc19dKSkvLFxuICAgICAgICAvLyAgICAgICAgICgxKSBhbmQgKDIpIGNhbiBvbmx5IGJlIGEgUmlnaHQgRGVsaW1pdGVyLiAoMykgYW5kICg0KSBjYW4gb25seSBiZSBMZWZ0LiAgKDUpIGFuZCAoNikgY2FuIGJlIGVpdGhlciBMZWZ0IG9yIFJpZ2h0LlxuICAgICAgICAvLyAgICAgICAgIHwgU2tpcCBvcnBoYW4gaW5zaWRlIHN0cm9uZyAgICAgIHwgQ29uc3VtZSB0byBkZWxpbSB8ICgxKSAjKioqICAgICAgICAgICAgICB8ICgyKSBhKioqIywgYSoqKiAgICAgICAgICAgICAgICAgICAgfCAoMykgIyoqKmEsICoqKmEgICAgICAgICAgICAgICAgICB8ICg0KSAqKiojICAgICAgICAgICAgICAgICB8ICg1KSAjKioqIyAgICAgICAgICAgICAgICAgICAgICAgICB8ICg2KSBhKioqYVxuICAgICAgICByRGVsaW1Bc3Q6IC9eW15fKl0qP19fW15fKl0qP1xcKlteXypdKj8oPz1fXyl8W14qXSsoPz1bXipdKXwoPyFcXCopW3B1bmN0XShcXCorKSg/PVtcXHNdfCQpfFtecHVuY3RcXHNdKFxcKispKD8hXFwqKSg/PVtwdW5jdFxcc118JCl8KD8hXFwqKVtwdW5jdFxcc10oXFwqKykoPz1bXnB1bmN0XFxzXSl8W1xcc10oXFwqKykoPyFcXCopKD89W3B1bmN0XSl8KD8hXFwqKVtwdW5jdF0oXFwqKykoPyFcXCopKD89W3B1bmN0XSl8W15wdW5jdFxcc10oXFwqKykoPz1bXnB1bmN0XFxzXSkvLFxuICAgICAgICByRGVsaW1VbmQ6IC9eW15fKl0qP1xcKlxcKlteXypdKj9fW15fKl0qPyg/PVxcKlxcKil8W15fXSsoPz1bXl9dKXwoPyFfKVtwdW5jdF0oXyspKD89W1xcc118JCl8W15wdW5jdFxcc10oXyspKD8hXykoPz1bcHVuY3RcXHNdfCQpfCg/IV8pW3B1bmN0XFxzXShfKykoPz1bXnB1bmN0XFxzXSl8W1xcc10oXyspKD8hXykoPz1bcHVuY3RdKXwoPyFfKVtwdW5jdF0oXyspKD8hXykoPz1bcHVuY3RdKS8gLy8gXi0gTm90IGFsbG93ZWQgZm9yIF9cbiAgICB9LFxuICAgIGNvZGU6IC9eKGArKShbXmBdfFteYF1bXFxzXFxTXSo/W15gXSlcXDEoPyFgKS8sXG4gICAgYnI6IC9eKCB7Mix9fFxcXFwpXFxuKD8hXFxzKiQpLyxcbiAgICBkZWw6IG5vb3BUZXN0LFxuICAgIHRleHQ6IC9eKGArfFteYF0pKD86KD89IHsyLH1cXG4pfFtcXHNcXFNdKj8oPzooPz1bXFxcXDwhXFxbYCpfXXxcXGJffCQpfFteIF0oPz0gezIsfVxcbikpKS8sXG4gICAgcHVuY3R1YXRpb246IC9eKCg/IVsqX10pW1xcc3B1bmN0dWF0aW9uXSkvXG59O1xuLy8gbGlzdCBvZiB1bmljb2RlIHB1bmN0dWF0aW9uIG1hcmtzLCBwbHVzIGFueSBtaXNzaW5nIGNoYXJhY3RlcnMgZnJvbSBDb21tb25NYXJrIHNwZWNcbmlubGluZS5fcHVuY3R1YXRpb24gPSAnXFxcXHB7UH0kKzw9PmBefH4nO1xuaW5saW5lLnB1bmN0dWF0aW9uID0gZWRpdChpbmxpbmUucHVuY3R1YXRpb24sICd1JykucmVwbGFjZSgvcHVuY3R1YXRpb24vZywgaW5saW5lLl9wdW5jdHVhdGlvbikuZ2V0UmVnZXgoKTtcbi8vIHNlcXVlbmNlcyBlbSBzaG91bGQgc2tpcCBvdmVyIFt0aXRsZV0obGluayksIGBjb2RlYCwgPGh0bWw+XG5pbmxpbmUuYmxvY2tTa2lwID0gL1xcW1teW1xcXV0qP1xcXVxcKFteXFwoXFwpXSo/XFwpfGBbXmBdKj9gfDxbXjw+XSo/Pi9nO1xuaW5saW5lLmFueVB1bmN0dWF0aW9uID0gL1xcXFxbcHVuY3RdL2c7XG5pbmxpbmUuX2VzY2FwZXMgPSAvXFxcXChbcHVuY3RdKS9nO1xuaW5saW5lLl9jb21tZW50ID0gZWRpdChibG9jay5fY29tbWVudCkucmVwbGFjZSgnKD86LS0+fCQpJywgJy0tPicpLmdldFJlZ2V4KCk7XG5pbmxpbmUuZW1TdHJvbmcubERlbGltID0gZWRpdChpbmxpbmUuZW1TdHJvbmcubERlbGltLCAndScpXG4gICAgLnJlcGxhY2UoL3B1bmN0L2csIGlubGluZS5fcHVuY3R1YXRpb24pXG4gICAgLmdldFJlZ2V4KCk7XG5pbmxpbmUuZW1TdHJvbmcuckRlbGltQXN0ID0gZWRpdChpbmxpbmUuZW1TdHJvbmcuckRlbGltQXN0LCAnZ3UnKVxuICAgIC5yZXBsYWNlKC9wdW5jdC9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKVxuICAgIC5nZXRSZWdleCgpO1xuaW5saW5lLmVtU3Ryb25nLnJEZWxpbVVuZCA9IGVkaXQoaW5saW5lLmVtU3Ryb25nLnJEZWxpbVVuZCwgJ2d1JylcbiAgICAucmVwbGFjZSgvcHVuY3QvZywgaW5saW5lLl9wdW5jdHVhdGlvbilcbiAgICAuZ2V0UmVnZXgoKTtcbmlubGluZS5hbnlQdW5jdHVhdGlvbiA9IGVkaXQoaW5saW5lLmFueVB1bmN0dWF0aW9uLCAnZ3UnKVxuICAgIC5yZXBsYWNlKC9wdW5jdC9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKVxuICAgIC5nZXRSZWdleCgpO1xuaW5saW5lLl9lc2NhcGVzID0gZWRpdChpbmxpbmUuX2VzY2FwZXMsICdndScpXG4gICAgLnJlcGxhY2UoL3B1bmN0L2csIGlubGluZS5fcHVuY3R1YXRpb24pXG4gICAgLmdldFJlZ2V4KCk7XG5pbmxpbmUuX3NjaGVtZSA9IC9bYS16QS1aXVthLXpBLVowLTkrLi1dezEsMzF9LztcbmlubGluZS5fZW1haWwgPSAvW2EtekEtWjAtOS4hIyQlJicqKy89P15fYHt8fX4tXSsoQClbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKyg/IVstX10pLztcbmlubGluZS5hdXRvbGluayA9IGVkaXQoaW5saW5lLmF1dG9saW5rKVxuICAgIC5yZXBsYWNlKCdzY2hlbWUnLCBpbmxpbmUuX3NjaGVtZSlcbiAgICAucmVwbGFjZSgnZW1haWwnLCBpbmxpbmUuX2VtYWlsKVxuICAgIC5nZXRSZWdleCgpO1xuaW5saW5lLl9hdHRyaWJ1dGUgPSAvXFxzK1thLXpBLVo6X11bXFx3LjotXSooPzpcXHMqPVxccypcIlteXCJdKlwifFxccyo9XFxzKidbXiddKid8XFxzKj1cXHMqW15cXHNcIic9PD5gXSspPy87XG5pbmxpbmUudGFnID0gZWRpdChpbmxpbmUudGFnKVxuICAgIC5yZXBsYWNlKCdjb21tZW50JywgaW5saW5lLl9jb21tZW50KVxuICAgIC5yZXBsYWNlKCdhdHRyaWJ1dGUnLCBpbmxpbmUuX2F0dHJpYnV0ZSlcbiAgICAuZ2V0UmVnZXgoKTtcbmlubGluZS5fbGFiZWwgPSAvKD86XFxbKD86XFxcXC58W15cXFtcXF1cXFxcXSkqXFxdfFxcXFwufGBbXmBdKmB8W15cXFtcXF1cXFxcYF0pKj8vO1xuaW5saW5lLl9ocmVmID0gLzwoPzpcXFxcLnxbXlxcbjw+XFxcXF0pKz58W15cXHNcXHgwMC1cXHgxZl0qLztcbmlubGluZS5fdGl0bGUgPSAvXCIoPzpcXFxcXCI/fFteXCJcXFxcXSkqXCJ8Jyg/OlxcXFwnP3xbXidcXFxcXSkqJ3xcXCgoPzpcXFxcXFwpP3xbXilcXFxcXSkqXFwpLztcbmlubGluZS5saW5rID0gZWRpdChpbmxpbmUubGluaylcbiAgICAucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUuX2xhYmVsKVxuICAgIC5yZXBsYWNlKCdocmVmJywgaW5saW5lLl9ocmVmKVxuICAgIC5yZXBsYWNlKCd0aXRsZScsIGlubGluZS5fdGl0bGUpXG4gICAgLmdldFJlZ2V4KCk7XG5pbmxpbmUucmVmbGluayA9IGVkaXQoaW5saW5lLnJlZmxpbmspXG4gICAgLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbClcbiAgICAucmVwbGFjZSgncmVmJywgYmxvY2suX2xhYmVsKVxuICAgIC5nZXRSZWdleCgpO1xuaW5saW5lLm5vbGluayA9IGVkaXQoaW5saW5lLm5vbGluaylcbiAgICAucmVwbGFjZSgncmVmJywgYmxvY2suX2xhYmVsKVxuICAgIC5nZXRSZWdleCgpO1xuaW5saW5lLnJlZmxpbmtTZWFyY2ggPSBlZGl0KGlubGluZS5yZWZsaW5rU2VhcmNoLCAnZycpXG4gICAgLnJlcGxhY2UoJ3JlZmxpbmsnLCBpbmxpbmUucmVmbGluaylcbiAgICAucmVwbGFjZSgnbm9saW5rJywgaW5saW5lLm5vbGluaylcbiAgICAuZ2V0UmVnZXgoKTtcbi8qKlxuICogTm9ybWFsIElubGluZSBHcmFtbWFyXG4gKi9cbmlubGluZS5ub3JtYWwgPSB7IC4uLmlubGluZSB9O1xuLyoqXG4gKiBQZWRhbnRpYyBJbmxpbmUgR3JhbW1hclxuICovXG5pbmxpbmUucGVkYW50aWMgPSB7XG4gICAgLi4uaW5saW5lLm5vcm1hbCxcbiAgICBzdHJvbmc6IHtcbiAgICAgICAgc3RhcnQ6IC9eX198XFwqXFwqLyxcbiAgICAgICAgbWlkZGxlOiAvXl9fKD89XFxTKShbXFxzXFxTXSo/XFxTKV9fKD8hXyl8XlxcKlxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCpcXCooPyFcXCopLyxcbiAgICAgICAgZW5kQXN0OiAvXFwqXFwqKD8hXFwqKS9nLFxuICAgICAgICBlbmRVbmQ6IC9fXyg/IV8pL2dcbiAgICB9LFxuICAgIGVtOiB7XG4gICAgICAgIHN0YXJ0OiAvXl98XFwqLyxcbiAgICAgICAgbWlkZGxlOiAvXigpXFwqKD89XFxTKShbXFxzXFxTXSo/XFxTKVxcKig/IVxcKil8Xl8oPz1cXFMpKFtcXHNcXFNdKj9cXFMpXyg/IV8pLyxcbiAgICAgICAgZW5kQXN0OiAvXFwqKD8hXFwqKS9nLFxuICAgICAgICBlbmRVbmQ6IC9fKD8hXykvZ1xuICAgIH0sXG4gICAgbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxcKCguKj8pXFwpLylcbiAgICAgICAgLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbClcbiAgICAgICAgLmdldFJlZ2V4KCksXG4gICAgcmVmbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxccypcXFsoW15cXF1dKilcXF0vKVxuICAgICAgICAucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUuX2xhYmVsKVxuICAgICAgICAuZ2V0UmVnZXgoKVxufTtcbi8qKlxuICogR0ZNIElubGluZSBHcmFtbWFyXG4gKi9cbmlubGluZS5nZm0gPSB7XG4gICAgLi4uaW5saW5lLm5vcm1hbCxcbiAgICBlc2NhcGU6IGVkaXQoaW5saW5lLmVzY2FwZSkucmVwbGFjZSgnXSknLCAnfnxdKScpLmdldFJlZ2V4KCksXG4gICAgX2V4dGVuZGVkX2VtYWlsOiAvW0EtWmEtejAtOS5fKy1dKyhAKVthLXpBLVowLTktX10rKD86XFwuW2EtekEtWjAtOS1fXSpbYS16QS1aMC05XSkrKD8hWy1fXSkvLFxuICAgIHVybDogL14oKD86ZnRwfGh0dHBzPyk6XFwvXFwvfHd3d1xcLikoPzpbYS16QS1aMC05XFwtXStcXC4/KStbXlxcczxdKnxeZW1haWwvLFxuICAgIF9iYWNrcGVkYWw6IC8oPzpbXj8hLiw6OypfJ1wifigpJl0rfFxcKFteKV0qXFwpfCYoPyFbYS16QS1aMC05XSs7JCl8Wz8hLiw6OypfJ1wifildKyg/ISQpKSsvLFxuICAgIGRlbDogL14ofn4/KSg/PVteXFxzfl0pKFtcXHNcXFNdKj9bXlxcc35dKVxcMSg/PVtefl18JCkvLFxuICAgIHRleHQ6IC9eKFtgfl0rfFteYH5dKSg/Oig/PSB7Mix9XFxuKXwoPz1bYS16QS1aMC05LiEjJCUmJyorXFwvPT9fYHtcXHx9fi1dK0ApfFtcXHNcXFNdKj8oPzooPz1bXFxcXDwhXFxbYCp+X118XFxiX3xodHRwcz86XFwvXFwvfGZ0cDpcXC9cXC98d3d3XFwufCQpfFteIF0oPz0gezIsfVxcbil8W15hLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0oPz1bYS16QS1aMC05LiEjJCUmJyorXFwvPT9fYHtcXHx9fi1dK0ApKSkvXG59O1xuaW5saW5lLmdmbS51cmwgPSBlZGl0KGlubGluZS5nZm0udXJsLCAnaScpXG4gICAgLnJlcGxhY2UoJ2VtYWlsJywgaW5saW5lLmdmbS5fZXh0ZW5kZWRfZW1haWwpXG4gICAgLmdldFJlZ2V4KCk7XG4vKipcbiAqIEdGTSArIExpbmUgQnJlYWtzIElubGluZSBHcmFtbWFyXG4gKi9cbmlubGluZS5icmVha3MgPSB7XG4gICAgLi4uaW5saW5lLmdmbSxcbiAgICBicjogZWRpdChpbmxpbmUuYnIpLnJlcGxhY2UoJ3syLH0nLCAnKicpLmdldFJlZ2V4KCksXG4gICAgdGV4dDogZWRpdChpbmxpbmUuZ2ZtLnRleHQpXG4gICAgICAgIC5yZXBsYWNlKCdcXFxcYl8nLCAnXFxcXGJffCB7Mix9XFxcXG4nKVxuICAgICAgICAucmVwbGFjZSgvXFx7MixcXH0vZywgJyonKVxuICAgICAgICAuZ2V0UmVnZXgoKVxufTtcblxuLyoqXG4gKiBCbG9jayBMZXhlclxuICovXG5jbGFzcyBfTGV4ZXIge1xuICAgIHRva2VucztcbiAgICBvcHRpb25zO1xuICAgIHN0YXRlO1xuICAgIHRva2VuaXplcjtcbiAgICBpbmxpbmVRdWV1ZTtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIC8vIFRva2VuTGlzdCBjYW5ub3QgYmUgY3JlYXRlZCBpbiBvbmUgZ29cbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgICB0aGlzLnRva2Vucy5saW5rcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgX2RlZmF1bHRzO1xuICAgICAgICB0aGlzLm9wdGlvbnMudG9rZW5pemVyID0gdGhpcy5vcHRpb25zLnRva2VuaXplciB8fCBuZXcgX1Rva2VuaXplcigpO1xuICAgICAgICB0aGlzLnRva2VuaXplciA9IHRoaXMub3B0aW9ucy50b2tlbml6ZXI7XG4gICAgICAgIHRoaXMudG9rZW5pemVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHRoaXMudG9rZW5pemVyLmxleGVyID0gdGhpcztcbiAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgaW5MaW5rOiBmYWxzZSxcbiAgICAgICAgICAgIGluUmF3QmxvY2s6IGZhbHNlLFxuICAgICAgICAgICAgdG9wOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJ1bGVzID0ge1xuICAgICAgICAgICAgYmxvY2s6IGJsb2NrLm5vcm1hbCxcbiAgICAgICAgICAgIGlubGluZTogaW5saW5lLm5vcm1hbFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICBydWxlcy5ibG9jayA9IGJsb2NrLnBlZGFudGljO1xuICAgICAgICAgICAgcnVsZXMuaW5saW5lID0gaW5saW5lLnBlZGFudGljO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICAgICAgICAgIHJ1bGVzLmJsb2NrID0gYmxvY2suZ2ZtO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5icmVha3MpIHtcbiAgICAgICAgICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUuYnJlYWtzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcnVsZXMuaW5saW5lID0gaW5saW5lLmdmbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRva2VuaXplci5ydWxlcyA9IHJ1bGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvc2UgUnVsZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IHJ1bGVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgICBpbmxpbmVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIExleCBNZXRob2RcbiAgICAgKi9cbiAgICBzdGF0aWMgbGV4KHNyYywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBsZXhlciA9IG5ldyBfTGV4ZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBsZXhlci5sZXgoc3JjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIExleCBJbmxpbmUgTWV0aG9kXG4gICAgICovXG4gICAgc3RhdGljIGxleElubGluZShzcmMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbGV4ZXIgPSBuZXcgX0xleGVyKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbGV4ZXIuaW5saW5lVG9rZW5zKHNyYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXByb2Nlc3NpbmdcbiAgICAgKi9cbiAgICBsZXgoc3JjKSB7XG4gICAgICAgIHNyYyA9IHNyY1xuICAgICAgICAgICAgLnJlcGxhY2UoL1xcclxcbnxcXHIvZywgJ1xcbicpO1xuICAgICAgICB0aGlzLmJsb2NrVG9rZW5zKHNyYywgdGhpcy50b2tlbnMpO1xuICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgd2hpbGUgKG5leHQgPSB0aGlzLmlubGluZVF1ZXVlLnNoaWZ0KCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5saW5lVG9rZW5zKG5leHQuc3JjLCBuZXh0LnRva2Vucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zO1xuICAgIH1cbiAgICBibG9ja1Rva2VucyhzcmMsIHRva2VucyA9IFtdKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKC9cXHQvZywgJyAgICAnKS5yZXBsYWNlKC9eICskL2dtLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzcmMgPSBzcmMucmVwbGFjZSgvXiggKikoXFx0KykvZ20sIChfLCBsZWFkaW5nLCB0YWJzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlYWRpbmcgKyAnICAgICcucmVwZWF0KHRhYnMubGVuZ3RoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b2tlbjtcbiAgICAgICAgbGV0IGxhc3RUb2tlbjtcbiAgICAgICAgbGV0IGN1dFNyYztcbiAgICAgICAgbGV0IGxhc3RQYXJhZ3JhcGhDbGlwcGVkO1xuICAgICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5ibG9ja1xuICAgICAgICAgICAgICAgICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmJsb2NrLnNvbWUoKGV4dFRva2VuaXplcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPSBleHRUb2tlbml6ZXIuY2FsbCh7IGxleGVyOiB0aGlzIH0sIHNyYywgdG9rZW5zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbmV3bGluZVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuc3BhY2Uoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnJhdy5sZW5ndGggPT09IDEgJiYgdG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBhIHNpbmdsZSBcXG4gYXMgYSBzcGFjZXIsIGl0J3MgdGVybWluYXRpbmcgdGhlIGxhc3QgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gbW92ZSBpdCB0aGVyZSBzbyB0aGF0IHdlIGRvbid0IGdldCB1bm5lY2Vzc2FyeSBwYXJhZ3JhcGggdGFnc1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnJhdyArPSAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb2RlXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5jb2RlKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgLy8gQW4gaW5kZW50ZWQgY29kZSBibG9jayBjYW5ub3QgaW50ZXJydXB0IGEgcGFyYWdyYXBoLlxuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4gJiYgKGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJyB8fCBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmZW5jZXNcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmZlbmNlcyhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoZWFkaW5nXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5oZWFkaW5nKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhyXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ocihzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBibG9ja3F1b3RlXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ibG9ja3F1b3RlKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxpc3RcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxpc3Qoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaHRtbFxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaHRtbChzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZWZcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmRlZihzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4gJiYgKGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJyB8fCBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2Vucy5saW5rc1t0b2tlbi50YWddID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogdG9rZW4uaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0b2tlbi50aXRsZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRhYmxlIChnZm0pXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50YWJsZShzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsaGVhZGluZ1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGhlYWRpbmcoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdG9wLWxldmVsIHBhcmFncmFwaFxuICAgICAgICAgICAgLy8gcHJldmVudCBwYXJhZ3JhcGggY29uc3VtaW5nIGV4dGVuc2lvbnMgYnkgY2xpcHBpbmcgJ3NyYycgdG8gZXh0ZW5zaW9uIHN0YXJ0XG4gICAgICAgICAgICBjdXRTcmMgPSBzcmM7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRCbG9jaykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcFNyYyA9IHNyYy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcFN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnN0YXJ0QmxvY2suZm9yRWFjaCgoZ2V0U3RhcnRJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wU3RhcnQgPSBnZXRTdGFydEluZGV4LmNhbGwoeyBsZXhlcjogdGhpcyB9LCB0ZW1wU3JjKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wU3RhcnQgPT09ICdudW1iZXInICYmIHRlbXBTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gTWF0aC5taW4oc3RhcnRJbmRleCwgdGVtcFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4IDwgSW5maW5pdHkgJiYgc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1dFNyYyA9IHNyYy5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnRvcCAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5wYXJhZ3JhcGgoY3V0U3JjKSkpIHtcbiAgICAgICAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UGFyYWdyYXBoQ2xpcHBlZCAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RQYXJhZ3JhcGhDbGlwcGVkID0gKGN1dFNyYy5sZW5ndGggIT09IHNyYy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXh0XG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50ZXh0KHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9ICdcXG4nICsgdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLnRvcCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICAgIGlubGluZShzcmMsIHRva2VucyA9IFtdKSB7XG4gICAgICAgIHRoaXMuaW5saW5lUXVldWUucHVzaCh7IHNyYywgdG9rZW5zIH0pO1xuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZXhpbmcvQ29tcGlsaW5nXG4gICAgICovXG4gICAgaW5saW5lVG9rZW5zKHNyYywgdG9rZW5zID0gW10pIHtcbiAgICAgICAgbGV0IHRva2VuLCBsYXN0VG9rZW4sIGN1dFNyYztcbiAgICAgICAgLy8gU3RyaW5nIHdpdGggbGlua3MgbWFza2VkIHRvIGF2b2lkIGludGVyZmVyZW5jZSB3aXRoIGVtIGFuZCBzdHJvbmdcbiAgICAgICAgbGV0IG1hc2tlZFNyYyA9IHNyYztcbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICBsZXQga2VlcFByZXZDaGFyLCBwcmV2Q2hhcjtcbiAgICAgICAgLy8gTWFzayBvdXQgcmVmbGlua3NcbiAgICAgICAgaWYgKHRoaXMudG9rZW5zLmxpbmtzKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rcyA9IE9iamVjdC5rZXlzKHRoaXMudG9rZW5zLmxpbmtzKTtcbiAgICAgICAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlua3MuaW5jbHVkZXMobWF0Y2hbMF0uc2xpY2UobWF0Y2hbMF0ubGFzdEluZGV4T2YoJ1snKSArIDEsIC0xKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnWycgKyAnYScucmVwZWF0KG1hdGNoWzBdLmxlbmd0aCAtIDIpICsgJ10nICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmxhc3RJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFzayBvdXQgb3RoZXIgYmxvY2tzXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYmxvY2tTa2lwLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICdbJyArICdhJy5yZXBlYXQobWF0Y2hbMF0ubGVuZ3RoIC0gMikgKyAnXScgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmJsb2NrU2tpcC5sYXN0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1hc2sgb3V0IGVzY2FwZWQgY2hhcmFjdGVyc1xuICAgICAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmFueVB1bmN0dWF0aW9uLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICcrKycgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmFueVB1bmN0dWF0aW9uLmxhc3RJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHNyYykge1xuICAgICAgICAgICAgaWYgKCFrZWVwUHJldkNoYXIpIHtcbiAgICAgICAgICAgICAgICBwcmV2Q2hhciA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2VlcFByZXZDaGFyID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBleHRlbnNpb25zXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5pbmxpbmVcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5pbmxpbmUuc29tZSgoZXh0VG9rZW5pemVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9IGV4dFRva2VuaXplci5jYWxsKHsgbGV4ZXI6IHRoaXMgfSwgc3JjLCB0b2tlbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2NhcGVcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmVzY2FwZShzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0YWdcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhZyhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4gJiYgdG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSB0b2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9IHRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGlua1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGluayhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZWZsaW5rLCBub2xpbmtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnJlZmxpbmsoc3JjLCB0aGlzLnRva2Vucy5saW5rcykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiB0b2tlbi50eXBlID09PSAndGV4dCcgJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbSAmIHN0cm9uZ1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZW1TdHJvbmcoc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29kZVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuY29kZXNwYW4oc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYnJcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmJyKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRlbCAoZ2ZtKVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZGVsKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGF1dG9saW5rXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5hdXRvbGluayhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1cmwgKGdmbSlcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0ZS5pbkxpbmsgJiYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudXJsKHNyYykpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXh0XG4gICAgICAgICAgICAvLyBwcmV2ZW50IGlubGluZVRleHQgY29uc3VtaW5nIGV4dGVuc2lvbnMgYnkgY2xpcHBpbmcgJ3NyYycgdG8gZXh0ZW5zaW9uIHN0YXJ0XG4gICAgICAgICAgICBjdXRTcmMgPSBzcmM7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRJbmxpbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBTcmMgPSBzcmMuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgbGV0IHRlbXBTdGFydDtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydElubGluZS5mb3JFYWNoKChnZXRTdGFydEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBTdGFydCA9IGdldFN0YXJ0SW5kZXguY2FsbCh7IGxleGVyOiB0aGlzIH0sIHRlbXBTcmMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBTdGFydCA9PT0gJ251bWJlcicgJiYgdGVtcFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBNYXRoLm1pbihzdGFydEluZGV4LCB0ZW1wU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPCBJbmZpbml0eSAmJiBzdGFydEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3V0U3JjID0gc3JjLnN1YnN0cmluZygwLCBzdGFydEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaW5saW5lVGV4dChjdXRTcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4ucmF3LnNsaWNlKC0xKSAhPT0gJ18nKSB7IC8vIFRyYWNrIHByZXZDaGFyIGJlZm9yZSBzdHJpbmcgb2YgX19fXyBzdGFydGVkXG4gICAgICAgICAgICAgICAgICAgIHByZXZDaGFyID0gdG9rZW4ucmF3LnNsaWNlKC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2VlcFByZXZDaGFyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4gJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG59XG5cbi8qKlxuICogUmVuZGVyZXJcbiAqL1xuY2xhc3MgX1JlbmRlcmVyIHtcbiAgICBvcHRpb25zO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBfZGVmYXVsdHM7XG4gICAgfVxuICAgIGNvZGUoY29kZSwgaW5mb3N0cmluZywgZXNjYXBlZCkge1xuICAgICAgICBjb25zdCBsYW5nID0gKGluZm9zdHJpbmcgfHwgJycpLm1hdGNoKC9eXFxTKi8pPy5bMF07XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UoL1xcbiQvLCAnJykgKyAnXFxuJztcbiAgICAgICAgaWYgKCFsYW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxwcmU+PGNvZGU+J1xuICAgICAgICAgICAgICAgICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlKGNvZGUsIHRydWUpKVxuICAgICAgICAgICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLSdcbiAgICAgICAgICAgICsgZXNjYXBlKGxhbmcpXG4gICAgICAgICAgICArICdcIj4nXG4gICAgICAgICAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZShjb2RlLCB0cnVlKSlcbiAgICAgICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICAgIH1cbiAgICBibG9ja3F1b3RlKHF1b3RlKSB7XG4gICAgICAgIHJldHVybiBgPGJsb2NrcXVvdGU+XFxuJHtxdW90ZX08L2Jsb2NrcXVvdGU+XFxuYDtcbiAgICB9XG4gICAgaHRtbChodG1sLCBibG9jaykge1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG4gICAgaGVhZGluZyh0ZXh0LCBsZXZlbCwgcmF3KSB7XG4gICAgICAgIC8vIGlnbm9yZSBJRHNcbiAgICAgICAgcmV0dXJuIGA8aCR7bGV2ZWx9PiR7dGV4dH08L2gke2xldmVsfT5cXG5gO1xuICAgIH1cbiAgICBocigpIHtcbiAgICAgICAgcmV0dXJuICc8aHI+XFxuJztcbiAgICB9XG4gICAgbGlzdChib2R5LCBvcmRlcmVkLCBzdGFydCkge1xuICAgICAgICBjb25zdCB0eXBlID0gb3JkZXJlZCA/ICdvbCcgOiAndWwnO1xuICAgICAgICBjb25zdCBzdGFydGF0dCA9IChvcmRlcmVkICYmIHN0YXJ0ICE9PSAxKSA/ICgnIHN0YXJ0PVwiJyArIHN0YXJ0ICsgJ1wiJykgOiAnJztcbiAgICAgICAgcmV0dXJuICc8JyArIHR5cGUgKyBzdGFydGF0dCArICc+XFxuJyArIGJvZHkgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbiAgICB9XG4gICAgbGlzdGl0ZW0odGV4dCwgdGFzaywgY2hlY2tlZCkge1xuICAgICAgICByZXR1cm4gYDxsaT4ke3RleHR9PC9saT5cXG5gO1xuICAgIH1cbiAgICBjaGVja2JveChjaGVja2VkKSB7XG4gICAgICAgIHJldHVybiAnPGlucHV0ICdcbiAgICAgICAgICAgICsgKGNoZWNrZWQgPyAnY2hlY2tlZD1cIlwiICcgOiAnJylcbiAgICAgICAgICAgICsgJ2Rpc2FibGVkPVwiXCIgdHlwZT1cImNoZWNrYm94XCI+JztcbiAgICB9XG4gICAgcGFyYWdyYXBoKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIGA8cD4ke3RleHR9PC9wPlxcbmA7XG4gICAgfVxuICAgIHRhYmxlKGhlYWRlciwgYm9keSkge1xuICAgICAgICBpZiAoYm9keSlcbiAgICAgICAgICAgIGJvZHkgPSBgPHRib2R5PiR7Ym9keX08L3Rib2R5PmA7XG4gICAgICAgIHJldHVybiAnPHRhYmxlPlxcbidcbiAgICAgICAgICAgICsgJzx0aGVhZD5cXG4nXG4gICAgICAgICAgICArIGhlYWRlclxuICAgICAgICAgICAgKyAnPC90aGVhZD5cXG4nXG4gICAgICAgICAgICArIGJvZHlcbiAgICAgICAgICAgICsgJzwvdGFibGU+XFxuJztcbiAgICB9XG4gICAgdGFibGVyb3coY29udGVudCkge1xuICAgICAgICByZXR1cm4gYDx0cj5cXG4ke2NvbnRlbnR9PC90cj5cXG5gO1xuICAgIH1cbiAgICB0YWJsZWNlbGwoY29udGVudCwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGZsYWdzLmhlYWRlciA/ICd0aCcgOiAndGQnO1xuICAgICAgICBjb25zdCB0YWcgPSBmbGFncy5hbGlnblxuICAgICAgICAgICAgPyBgPCR7dHlwZX0gYWxpZ249XCIke2ZsYWdzLmFsaWdufVwiPmBcbiAgICAgICAgICAgIDogYDwke3R5cGV9PmA7XG4gICAgICAgIHJldHVybiB0YWcgKyBjb250ZW50ICsgYDwvJHt0eXBlfT5cXG5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzcGFuIGxldmVsIHJlbmRlcmVyXG4gICAgICovXG4gICAgc3Ryb25nKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIGA8c3Ryb25nPiR7dGV4dH08L3N0cm9uZz5gO1xuICAgIH1cbiAgICBlbSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBgPGVtPiR7dGV4dH08L2VtPmA7XG4gICAgfVxuICAgIGNvZGVzcGFuKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIGA8Y29kZT4ke3RleHR9PC9jb2RlPmA7XG4gICAgfVxuICAgIGJyKCkge1xuICAgICAgICByZXR1cm4gJzxicj4nO1xuICAgIH1cbiAgICBkZWwodGV4dCkge1xuICAgICAgICByZXR1cm4gYDxkZWw+JHt0ZXh0fTwvZGVsPmA7XG4gICAgfVxuICAgIGxpbmsoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgICAgY29uc3QgY2xlYW5IcmVmID0gY2xlYW5VcmwoaHJlZik7XG4gICAgICAgIGlmIChjbGVhbkhyZWYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGhyZWYgPSBjbGVhbkhyZWY7XG4gICAgICAgIGxldCBvdXQgPSAnPGEgaHJlZj1cIicgKyBocmVmICsgJ1wiJztcbiAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyB0aXRsZSArICdcIic7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICc+JyArIHRleHQgKyAnPC9hPic7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGltYWdlKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNsZWFuSHJlZiA9IGNsZWFuVXJsKGhyZWYpO1xuICAgICAgICBpZiAoY2xlYW5IcmVmID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICBocmVmID0gY2xlYW5IcmVmO1xuICAgICAgICBsZXQgb3V0ID0gYDxpbWcgc3JjPVwiJHtocmVmfVwiIGFsdD1cIiR7dGV4dH1cImA7XG4gICAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICAgICAgb3V0ICs9IGAgdGl0bGU9XCIke3RpdGxlfVwiYDtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJz4nO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB0ZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIFRleHRSZW5kZXJlclxuICogcmV0dXJucyBvbmx5IHRoZSB0ZXh0dWFsIHBhcnQgb2YgdGhlIHRva2VuXG4gKi9cbmNsYXNzIF9UZXh0UmVuZGVyZXIge1xuICAgIC8vIG5vIG5lZWQgZm9yIGJsb2NrIGxldmVsIHJlbmRlcmVyc1xuICAgIHN0cm9uZyh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBlbSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBjb2Rlc3Bhbih0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBkZWwodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgaHRtbCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICB0ZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGxpbmsoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGV4dDtcbiAgICB9XG4gICAgaW1hZ2UoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGV4dDtcbiAgICB9XG4gICAgYnIoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG5cbi8qKlxuICogUGFyc2luZyAmIENvbXBpbGluZ1xuICovXG5jbGFzcyBfUGFyc2VyIHtcbiAgICBvcHRpb25zO1xuICAgIHJlbmRlcmVyO1xuICAgIHRleHRSZW5kZXJlcjtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgX2RlZmF1bHRzO1xuICAgICAgICB0aGlzLm9wdGlvbnMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgbmV3IF9SZW5kZXJlcigpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHRoaXMudGV4dFJlbmRlcmVyID0gbmV3IF9UZXh0UmVuZGVyZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIFBhcnNlIE1ldGhvZFxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IF9QYXJzZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2UodG9rZW5zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIFBhcnNlIElubGluZSBNZXRob2RcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VJbmxpbmUodG9rZW5zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBfUGFyc2VyKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIExvb3BcbiAgICAgKi9cbiAgICBwYXJzZSh0b2tlbnMsIHRvcCA9IHRydWUpIHtcbiAgICAgICAgbGV0IG91dCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICAvLyBSdW4gYW55IHJlbmRlcmVyIGV4dGVuc2lvbnNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW3Rva2VuLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJpY1Rva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW2dlbmVyaWNUb2tlbi50eXBlXS5jYWxsKHsgcGFyc2VyOiB0aGlzIH0sIGdlbmVyaWNUb2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHJldCAhPT0gZmFsc2UgfHwgIVsnc3BhY2UnLCAnaHInLCAnaGVhZGluZycsICdjb2RlJywgJ3RhYmxlJywgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcsICdodG1sJywgJ3BhcmFncmFwaCcsICd0ZXh0J10uaW5jbHVkZXMoZ2VuZXJpY1Rva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZXQgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnaHInOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmhyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdoZWFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkaW5nVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaGVhZGluZyh0aGlzLnBhcnNlSW5saW5lKGhlYWRpbmdUb2tlbi50b2tlbnMpLCBoZWFkaW5nVG9rZW4uZGVwdGgsIHVuZXNjYXBlKHRoaXMucGFyc2VJbmxpbmUoaGVhZGluZ1Rva2VuLnRva2VucywgdGhpcy50ZXh0UmVuZGVyZXIpKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdjb2RlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuY29kZShjb2RlVG9rZW4udGV4dCwgY29kZVRva2VuLmxhbmcsICEhY29kZVRva2VuLmVzY2FwZWQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAndGFibGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhlYWRlciA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAvLyBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNlbGwgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0YWJsZVRva2VuLmhlYWRlci5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbCh0aGlzLnBhcnNlSW5saW5lKHRhYmxlVG9rZW4uaGVhZGVyW2pdLnRva2VucyksIHsgaGVhZGVyOiB0cnVlLCBhbGlnbjogdGFibGVUb2tlbi5hbGlnbltqXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJvZHkgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0YWJsZVRva2VuLnJvd3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IHRhYmxlVG9rZW4ucm93c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcm93Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbCh0aGlzLnBhcnNlSW5saW5lKHJvd1trXS50b2tlbnMpLCB7IGhlYWRlcjogZmFsc2UsIGFsaWduOiB0YWJsZVRva2VuLmFsaWduW2tdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlKGhlYWRlciwgYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdibG9ja3F1b3RlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9ja3F1b3RlVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IHRoaXMucGFyc2UoYmxvY2txdW90ZVRva2VuLnRva2Vucyk7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmJsb2NrcXVvdGUoYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdsaXN0Jzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JkZXJlZCA9IGxpc3RUb2tlbi5vcmRlcmVkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGxpc3RUb2tlbi5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9vc2UgPSBsaXN0VG9rZW4ubG9vc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBib2R5ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGlzdFRva2VuLml0ZW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gbGlzdFRva2VuLml0ZW1zW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IGl0ZW0uY2hlY2tlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBpdGVtLnRhc2s7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbUJvZHkgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGVja2JveCA9IHRoaXMucmVuZGVyZXIuY2hlY2tib3goISFjaGVja2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9vc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW5zLmxlbmd0aCA+IDAgJiYgaXRlbS50b2tlbnNbMF0udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zWzBdLnRleHQgPSBjaGVja2JveCArICcgJyArIGl0ZW0udG9rZW5zWzBdLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50b2tlbnNbMF0udG9rZW5zICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vucy5sZW5ndGggPiAwICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udGV4dCA9IGNoZWNrYm94ICsgJyAnICsgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vucy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY2hlY2tib3ggKyAnICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtQm9keSArPSBjaGVja2JveCArICcgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtQm9keSArPSB0aGlzLnBhcnNlKGl0ZW0udG9rZW5zLCBsb29zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ICs9IHRoaXMucmVuZGVyZXIubGlzdGl0ZW0oaXRlbUJvZHksIHRhc2ssICEhY2hlY2tlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIubGlzdChib2R5LCBvcmRlcmVkLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdodG1sJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBodG1sVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaHRtbChodG1sVG9rZW4udGV4dCwgaHRtbFRva2VuLmJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3BhcmFncmFwaCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYWdyYXBoVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRoaXMucGFyc2VJbmxpbmUocGFyYWdyYXBoVG9rZW4udG9rZW5zKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dFRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGxldCBib2R5ID0gdGV4dFRva2VuLnRva2VucyA/IHRoaXMucGFyc2VJbmxpbmUodGV4dFRva2VuLnRva2VucykgOiB0ZXh0VG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgKyAxIDwgdG9rZW5zLmxlbmd0aCAmJiB0b2tlbnNbaSArIDFdLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFRva2VuID0gdG9rZW5zWysraV07XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ICs9ICdcXG4nICsgKHRleHRUb2tlbi50b2tlbnMgPyB0aGlzLnBhcnNlSW5saW5lKHRleHRUb2tlbi50b2tlbnMpIDogdGV4dFRva2VuLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0b3AgPyB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaChib2R5KSA6IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9ICdUb2tlbiB3aXRoIFwiJyArIHRva2VuLnR5cGUgKyAnXCIgdHlwZSB3YXMgbm90IGZvdW5kLic7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBJbmxpbmUgVG9rZW5zXG4gICAgICovXG4gICAgcGFyc2VJbmxpbmUodG9rZW5zLCByZW5kZXJlcikge1xuICAgICAgICByZW5kZXJlciA9IHJlbmRlcmVyIHx8IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIGxldCBvdXQgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgLy8gUnVuIGFueSByZW5kZXJlciBleHRlbnNpb25zXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXS5jYWxsKHsgcGFyc2VyOiB0aGlzIH0sIHRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0ICE9PSBmYWxzZSB8fCAhWydlc2NhcGUnLCAnaHRtbCcsICdsaW5rJywgJ2ltYWdlJywgJ3N0cm9uZycsICdlbScsICdjb2Rlc3BhbicsICdicicsICdkZWwnLCAndGV4dCddLmluY2x1ZGVzKHRva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZXQgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VzY2FwZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXNjYXBlVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnRleHQoZXNjYXBlVG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdodG1sJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWdUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuaHRtbCh0YWdUb2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2xpbmsnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmtUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIubGluayhsaW5rVG9rZW4uaHJlZiwgbGlua1Rva2VuLnRpdGxlLCB0aGlzLnBhcnNlSW5saW5lKGxpbmtUb2tlbi50b2tlbnMsIHJlbmRlcmVyKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdpbWFnZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuaW1hZ2UoaW1hZ2VUb2tlbi5ocmVmLCBpbWFnZVRva2VuLnRpdGxlLCBpbWFnZVRva2VuLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnc3Ryb25nJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJvbmdUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuc3Ryb25nKHRoaXMucGFyc2VJbmxpbmUoc3Ryb25nVG9rZW4udG9rZW5zLCByZW5kZXJlcikpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZW0nOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVtVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmVtKHRoaXMucGFyc2VJbmxpbmUoZW1Ub2tlbi50b2tlbnMsIHJlbmRlcmVyKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdjb2Rlc3Bhbic6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZXNwYW5Ub2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuY29kZXNwYW4oY29kZXNwYW5Ub2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2JyJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuYnIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2RlbCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmRlbCh0aGlzLnBhcnNlSW5saW5lKGRlbFRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIudGV4dCh0ZXh0VG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9ICdUb2tlbiB3aXRoIFwiJyArIHRva2VuLnR5cGUgKyAnXCIgdHlwZSB3YXMgbm90IGZvdW5kLic7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbn1cblxuY2xhc3MgX0hvb2tzIHtcbiAgICBvcHRpb25zO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBfZGVmYXVsdHM7XG4gICAgfVxuICAgIHN0YXRpYyBwYXNzVGhyb3VnaEhvb2tzID0gbmV3IFNldChbXG4gICAgICAgICdwcmVwcm9jZXNzJyxcbiAgICAgICAgJ3Bvc3Rwcm9jZXNzJ1xuICAgIF0pO1xuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgbWFya2Rvd24gYmVmb3JlIG1hcmtlZFxuICAgICAqL1xuICAgIHByZXByb2Nlc3MobWFya2Rvd24pIHtcbiAgICAgICAgcmV0dXJuIG1hcmtkb3duO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIEhUTUwgYWZ0ZXIgbWFya2VkIGlzIGZpbmlzaGVkXG4gICAgICovXG4gICAgcG9zdHByb2Nlc3MoaHRtbCkge1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG59XG5cbmNsYXNzIE1hcmtlZCB7XG4gICAgZGVmYXVsdHMgPSBfZ2V0RGVmYXVsdHMoKTtcbiAgICBvcHRpb25zID0gdGhpcy5zZXRPcHRpb25zO1xuICAgIHBhcnNlID0gdGhpcy4jcGFyc2VNYXJrZG93bihfTGV4ZXIubGV4LCBfUGFyc2VyLnBhcnNlKTtcbiAgICBwYXJzZUlubGluZSA9IHRoaXMuI3BhcnNlTWFya2Rvd24oX0xleGVyLmxleElubGluZSwgX1BhcnNlci5wYXJzZUlubGluZSk7XG4gICAgUGFyc2VyID0gX1BhcnNlcjtcbiAgICBSZW5kZXJlciA9IF9SZW5kZXJlcjtcbiAgICBUZXh0UmVuZGVyZXIgPSBfVGV4dFJlbmRlcmVyO1xuICAgIExleGVyID0gX0xleGVyO1xuICAgIFRva2VuaXplciA9IF9Ub2tlbml6ZXI7XG4gICAgSG9va3MgPSBfSG9va3M7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICB0aGlzLnVzZSguLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVuIGNhbGxiYWNrIGZvciBldmVyeSB0b2tlblxuICAgICAqL1xuICAgIHdhbGtUb2tlbnModG9rZW5zLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KGNhbGxiYWNrLmNhbGwodGhpcywgdG9rZW4pKTtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RhYmxlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWJsZVRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiB0YWJsZVRva2VuLmhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh0aGlzLndhbGtUb2tlbnMoY2VsbC50b2tlbnMsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGFibGVUb2tlbi5yb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2Ygcm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh0aGlzLndhbGtUb2tlbnMoY2VsbC50b2tlbnMsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2xpc3QnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHRoaXMud2Fsa1Rva2VucyhsaXN0VG9rZW4uaXRlbXMsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdlbmVyaWNUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0cy5leHRlbnNpb25zPy5jaGlsZFRva2Vucz8uW2dlbmVyaWNUb2tlbi50eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0cy5leHRlbnNpb25zLmNoaWxkVG9rZW5zW2dlbmVyaWNUb2tlbi50eXBlXS5mb3JFYWNoKChjaGlsZFRva2VucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKGdlbmVyaWNUb2tlbltjaGlsZFRva2Vuc10sIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChnZW5lcmljVG9rZW4udG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHRoaXMud2Fsa1Rva2VucyhnZW5lcmljVG9rZW4udG9rZW5zLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICAgIHVzZSguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmRlZmF1bHRzLmV4dGVuc2lvbnMgfHwgeyByZW5kZXJlcnM6IHt9LCBjaGlsZFRva2Vuczoge30gfTtcbiAgICAgICAgYXJncy5mb3JFYWNoKChwYWNrKSA9PiB7XG4gICAgICAgICAgICAvLyBjb3B5IG9wdGlvbnMgdG8gbmV3IG9iamVjdFxuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IHsgLi4ucGFjayB9O1xuICAgICAgICAgICAgLy8gc2V0IGFzeW5jIHRvIHRydWUgaWYgaXQgd2FzIHNldCB0byB0cnVlIGJlZm9yZVxuICAgICAgICAgICAgb3B0cy5hc3luYyA9IHRoaXMuZGVmYXVsdHMuYXN5bmMgfHwgb3B0cy5hc3luYyB8fCBmYWxzZTtcbiAgICAgICAgICAgIC8vID09LS0gUGFyc2UgXCJhZGRvblwiIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgICAgICAgICAgaWYgKHBhY2suZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgICAgIHBhY2suZXh0ZW5zaW9ucy5mb3JFYWNoKChleHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleHQubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHRlbnNpb24gbmFtZSByZXF1aXJlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgncmVuZGVyZXInIGluIGV4dCkgeyAvLyBSZW5kZXJlciBleHRlbnNpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2UmVuZGVyZXIgPSBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldlJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBleHRlbnNpb24gd2l0aCBmdW5jIHRvIHJ1biBuZXcgZXh0ZW5zaW9uIGJ1dCBmYWxsIGJhY2sgaWYgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmV0ID0gZXh0LnJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gcHJldlJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMucmVuZGVyZXJzW2V4dC5uYW1lXSA9IGV4dC5yZW5kZXJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoJ3Rva2VuaXplcicgaW4gZXh0KSB7IC8vIFRva2VuaXplciBFeHRlbnNpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4dC5sZXZlbCB8fCAoZXh0LmxldmVsICE9PSAnYmxvY2snICYmIGV4dC5sZXZlbCAhPT0gJ2lubGluZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXh0ZW5zaW9uIGxldmVsIG11c3QgYmUgJ2Jsb2NrJyBvciAnaW5saW5lJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dExldmVsID0gZXh0ZW5zaW9uc1tleHQubGV2ZWxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dExldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0TGV2ZWwudW5zaGlmdChleHQudG9rZW5pemVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0LmxldmVsXSA9IFtleHQudG9rZW5pemVyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHQuc3RhcnQpIHsgLy8gRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHN0YXJ0IG9mIHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dC5sZXZlbCA9PT0gJ2Jsb2NrJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9ucy5zdGFydEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0QmxvY2sucHVzaChleHQuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydEJsb2NrID0gW2V4dC5zdGFydF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXh0LmxldmVsID09PSAnaW5saW5lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9ucy5zdGFydElubGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydElubGluZS5wdXNoKGV4dC5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0SW5saW5lID0gW2V4dC5zdGFydF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCdjaGlsZFRva2VucycgaW4gZXh0ICYmIGV4dC5jaGlsZFRva2VucykgeyAvLyBDaGlsZCB0b2tlbnMgdG8gYmUgdmlzaXRlZCBieSB3YWxrVG9rZW5zXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLmNoaWxkVG9rZW5zW2V4dC5uYW1lXSA9IGV4dC5jaGlsZFRva2VucztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9wdHMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA9PS0tIFBhcnNlIFwib3ZlcndyaXRlXCIgZXh0ZW5zaW9ucyAtLT09IC8vXG4gICAgICAgICAgICBpZiAocGFjay5yZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5kZWZhdWx0cy5yZW5kZXJlciB8fCBuZXcgX1JlbmRlcmVyKHRoaXMuZGVmYXVsdHMpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBwYWNrLnJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyRnVuYyA9IHBhY2sucmVuZGVyZXJbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyS2V5ID0gcHJvcDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldlJlbmRlcmVyID0gcmVuZGVyZXJbcmVuZGVyZXJLZXldO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHJlbmRlcmVyIHdpdGggZnVuYyB0byBydW4gZXh0ZW5zaW9uLCBidXQgZmFsbCBiYWNrIGlmIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyW3JlbmRlcmVyS2V5XSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmV0ID0gcmVuZGVyZXJGdW5jLmFwcGx5KHJlbmRlcmVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gcHJldlJlbmRlcmVyLmFwcGx5KHJlbmRlcmVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdHMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWNrLnRva2VuaXplcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuaXplciA9IHRoaXMuZGVmYXVsdHMudG9rZW5pemVyIHx8IG5ldyBfVG9rZW5pemVyKHRoaXMuZGVmYXVsdHMpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBwYWNrLnRva2VuaXplcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbml6ZXJGdW5jID0gcGFjay50b2tlbml6ZXJbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuaXplcktleSA9IHByb3A7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZUb2tlbml6ZXIgPSB0b2tlbml6ZXJbdG9rZW5pemVyS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB0b2tlbml6ZXIgd2l0aCBmdW5jIHRvIHJ1biBleHRlbnNpb24sIGJ1dCBmYWxsIGJhY2sgaWYgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5pemVyW3Rva2VuaXplcktleV0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldCA9IHRva2VuaXplckZ1bmMuYXBwbHkodG9rZW5pemVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gcHJldlRva2VuaXplci5hcHBseSh0b2tlbml6ZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0cy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA9PS0tIFBhcnNlIEhvb2tzIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgICAgICAgICAgaWYgKHBhY2suaG9va3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBob29rcyA9IHRoaXMuZGVmYXVsdHMuaG9va3MgfHwgbmV3IF9Ib29rcygpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBwYWNrLmhvb2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhvb2tzRnVuYyA9IHBhY2suaG9va3NbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhvb2tzS2V5ID0gcHJvcDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldkhvb2sgPSBob29rc1tob29rc0tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChfSG9va3MucGFzc1Rocm91Z2hIb29rcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tzW2hvb2tzS2V5XSA9IChhcmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0cy5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhvb2tzRnVuYy5jYWxsKGhvb2tzLCBhcmcpKS50aGVuKHJldCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldkhvb2suY2FsbChob29rcywgcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IGhvb2tzRnVuYy5jYWxsKGhvb2tzLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2SG9vay5jYWxsKGhvb2tzLCByZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tzW2hvb2tzS2V5XSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldCA9IGhvb2tzRnVuYy5hcHBseShob29rcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gcHJldkhvb2suYXBwbHkoaG9va3MsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRzLmhvb2tzID0gaG9va3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA9PS0tIFBhcnNlIFdhbGtUb2tlbnMgZXh0ZW5zaW9ucyAtLT09IC8vXG4gICAgICAgICAgICBpZiAocGFjay53YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2Fsa1Rva2VucyA9IHRoaXMuZGVmYXVsdHMud2Fsa1Rva2VucztcbiAgICAgICAgICAgICAgICBjb25zdCBwYWNrV2Fsa3Rva2VucyA9IHBhY2sud2Fsa1Rva2VucztcbiAgICAgICAgICAgICAgICBvcHRzLndhbGtUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChwYWNrV2Fsa3Rva2Vucy5jYWxsKHRoaXMsIHRva2VuKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHdhbGtUb2tlbnMuY2FsbCh0aGlzLCB0b2tlbikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdHMgPSB7IC4uLnRoaXMuZGVmYXVsdHMsIC4uLm9wdHMgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRPcHRpb25zKG9wdCkge1xuICAgICAgICB0aGlzLmRlZmF1bHRzID0geyAuLi50aGlzLmRlZmF1bHRzLCAuLi5vcHQgfTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxleGVyKHNyYywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX0xleGVyLmxleChzcmMsIG9wdGlvbnMgPz8gdGhpcy5kZWZhdWx0cyk7XG4gICAgfVxuICAgIHBhcnNlcih0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9QYXJzZXIucGFyc2UodG9rZW5zLCBvcHRpb25zID8/IHRoaXMuZGVmYXVsdHMpO1xuICAgIH1cbiAgICAjcGFyc2VNYXJrZG93bihsZXhlciwgcGFyc2VyKSB7XG4gICAgICAgIHJldHVybiAoc3JjLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcmlnT3B0ID0geyAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBvcHQgPSB7IC4uLnRoaXMuZGVmYXVsdHMsIC4uLm9yaWdPcHQgfTtcbiAgICAgICAgICAgIC8vIFNob3cgd2FybmluZyBpZiBhbiBleHRlbnNpb24gc2V0IGFzeW5jIHRvIHRydWUgYnV0IHRoZSBwYXJzZSB3YXMgY2FsbGVkIHdpdGggYXN5bmM6IGZhbHNlXG4gICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0cy5hc3luYyA9PT0gdHJ1ZSAmJiBvcmlnT3B0LmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmICghb3B0LnNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ21hcmtlZCgpOiBUaGUgYXN5bmMgb3B0aW9uIHdhcyBzZXQgdG8gdHJ1ZSBieSBhbiBleHRlbnNpb24uIFRoZSBhc3luYzogZmFsc2Ugb3B0aW9uIHNlbnQgdG8gcGFyc2Ugd2lsbCBiZSBpZ25vcmVkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHQuYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGhyb3dFcnJvciA9IHRoaXMuI29uRXJyb3IoISFvcHQuc2lsZW50LCAhIW9wdC5hc3luYyk7XG4gICAgICAgICAgICAvLyB0aHJvdyBlcnJvciBpbiBjYXNlIG9mIG5vbiBzdHJpbmcgaW5wdXRcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAndW5kZWZpbmVkJyB8fCBzcmMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG9yIG51bGwnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgb2YgdHlwZSAnXG4gICAgICAgICAgICAgICAgICAgICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNyYykgKyAnLCBzdHJpbmcgZXhwZWN0ZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICAgICAgICAgICAgb3B0Lmhvb2tzLm9wdGlvbnMgPSBvcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0LmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShvcHQuaG9va3MgPyBvcHQuaG9va3MucHJlcHJvY2VzcyhzcmMpIDogc3JjKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihzcmMgPT4gbGV4ZXIoc3JjLCBvcHQpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbih0b2tlbnMgPT4gb3B0LndhbGtUb2tlbnMgPyBQcm9taXNlLmFsbCh0aGlzLndhbGtUb2tlbnModG9rZW5zLCBvcHQud2Fsa1Rva2VucykpLnRoZW4oKCkgPT4gdG9rZW5zKSA6IHRva2VucylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4odG9rZW5zID0+IHBhcnNlcih0b2tlbnMsIG9wdCkpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGh0bWwgPT4gb3B0Lmhvb2tzID8gb3B0Lmhvb2tzLnBvc3Rwcm9jZXNzKGh0bWwpIDogaHRtbClcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHRocm93RXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IG9wdC5ob29rcy5wcmVwcm9jZXNzKHNyYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VucyA9IGxleGVyKHNyYywgb3B0KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0LndhbGtUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53YWxrVG9rZW5zKHRva2Vucywgb3B0LndhbGtUb2tlbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaHRtbCA9IHBhcnNlcih0b2tlbnMsIG9wdCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICAgICAgICAgICAgICBodG1sID0gb3B0Lmhvb2tzLnBvc3Rwcm9jZXNzKGh0bWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgICNvbkVycm9yKHNpbGVudCwgYXN5bmMpIHtcbiAgICAgICAgcmV0dXJuIChlKSA9PiB7XG4gICAgICAgICAgICBlLm1lc3NhZ2UgKz0gJ1xcblBsZWFzZSByZXBvcnQgdGhpcyB0byBodHRwczovL2dpdGh1Yi5jb20vbWFya2VkanMvbWFya2VkLic7XG4gICAgICAgICAgICBpZiAoc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gJzxwPkFuIGVycm9yIG9jY3VycmVkOjwvcD48cHJlPidcbiAgICAgICAgICAgICAgICAgICAgKyBlc2NhcGUoZS5tZXNzYWdlICsgJycsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICsgJzwvcHJlPic7XG4gICAgICAgICAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhc3luYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5jb25zdCBtYXJrZWRJbnN0YW5jZSA9IG5ldyBNYXJrZWQoKTtcbmZ1bmN0aW9uIG1hcmtlZChzcmMsIG9wdCkge1xuICAgIHJldHVybiBtYXJrZWRJbnN0YW5jZS5wYXJzZShzcmMsIG9wdCk7XG59XG4vKipcbiAqIFNldHMgdGhlIGRlZmF1bHQgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyBIYXNoIG9mIG9wdGlvbnNcbiAqL1xubWFya2VkLm9wdGlvbnMgPVxuICAgIG1hcmtlZC5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgbWFya2VkSW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgbWFya2VkLmRlZmF1bHRzID0gbWFya2VkSW5zdGFuY2UuZGVmYXVsdHM7XG4gICAgICAgIGNoYW5nZURlZmF1bHRzKG1hcmtlZC5kZWZhdWx0cyk7XG4gICAgICAgIHJldHVybiBtYXJrZWQ7XG4gICAgfTtcbi8qKlxuICogR2V0cyB0aGUgb3JpZ2luYWwgbWFya2VkIGRlZmF1bHQgb3B0aW9ucy5cbiAqL1xubWFya2VkLmdldERlZmF1bHRzID0gX2dldERlZmF1bHRzO1xubWFya2VkLmRlZmF1bHRzID0gX2RlZmF1bHRzO1xuLyoqXG4gKiBVc2UgRXh0ZW5zaW9uXG4gKi9cbm1hcmtlZC51c2UgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIG1hcmtlZEluc3RhbmNlLnVzZSguLi5hcmdzKTtcbiAgICBtYXJrZWQuZGVmYXVsdHMgPSBtYXJrZWRJbnN0YW5jZS5kZWZhdWx0cztcbiAgICBjaGFuZ2VEZWZhdWx0cyhtYXJrZWQuZGVmYXVsdHMpO1xuICAgIHJldHVybiBtYXJrZWQ7XG59O1xuLyoqXG4gKiBSdW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IHRva2VuXG4gKi9cbm1hcmtlZC53YWxrVG9rZW5zID0gZnVuY3Rpb24gKHRva2VucywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbWFya2VkSW5zdGFuY2Uud2Fsa1Rva2Vucyh0b2tlbnMsIGNhbGxiYWNrKTtcbn07XG4vKipcbiAqIENvbXBpbGVzIG1hcmtkb3duIHRvIEhUTUwgd2l0aG91dCBlbmNsb3NpbmcgYHBgIHRhZy5cbiAqXG4gKiBAcGFyYW0gc3JjIFN0cmluZyBvZiBtYXJrZG93biBzb3VyY2UgdG8gYmUgY29tcGlsZWRcbiAqIEBwYXJhbSBvcHRpb25zIEhhc2ggb2Ygb3B0aW9uc1xuICogQHJldHVybiBTdHJpbmcgb2YgY29tcGlsZWQgSFRNTFxuICovXG5tYXJrZWQucGFyc2VJbmxpbmUgPSBtYXJrZWRJbnN0YW5jZS5wYXJzZUlubGluZTtcbi8qKlxuICogRXhwb3NlXG4gKi9cbm1hcmtlZC5QYXJzZXIgPSBfUGFyc2VyO1xubWFya2VkLnBhcnNlciA9IF9QYXJzZXIucGFyc2U7XG5tYXJrZWQuUmVuZGVyZXIgPSBfUmVuZGVyZXI7XG5tYXJrZWQuVGV4dFJlbmRlcmVyID0gX1RleHRSZW5kZXJlcjtcbm1hcmtlZC5MZXhlciA9IF9MZXhlcjtcbm1hcmtlZC5sZXhlciA9IF9MZXhlci5sZXg7XG5tYXJrZWQuVG9rZW5pemVyID0gX1Rva2VuaXplcjtcbm1hcmtlZC5Ib29rcyA9IF9Ib29rcztcbm1hcmtlZC5wYXJzZSA9IG1hcmtlZDtcbmNvbnN0IG9wdGlvbnMgPSBtYXJrZWQub3B0aW9ucztcbmNvbnN0IHNldE9wdGlvbnMgPSBtYXJrZWQuc2V0T3B0aW9ucztcbmNvbnN0IHVzZSA9IG1hcmtlZC51c2U7XG5jb25zdCB3YWxrVG9rZW5zID0gbWFya2VkLndhbGtUb2tlbnM7XG5jb25zdCBwYXJzZUlubGluZSA9IG1hcmtlZC5wYXJzZUlubGluZTtcbmNvbnN0IHBhcnNlID0gbWFya2VkO1xuY29uc3QgcGFyc2VyID0gX1BhcnNlci5wYXJzZTtcbmNvbnN0IGxleGVyID0gX0xleGVyLmxleDtcblxuZXhwb3J0IHsgX0hvb2tzIGFzIEhvb2tzLCBfTGV4ZXIgYXMgTGV4ZXIsIE1hcmtlZCwgX1BhcnNlciBhcyBQYXJzZXIsIF9SZW5kZXJlciBhcyBSZW5kZXJlciwgX1RleHRSZW5kZXJlciBhcyBUZXh0UmVuZGVyZXIsIF9Ub2tlbml6ZXIgYXMgVG9rZW5pemVyLCBfZGVmYXVsdHMgYXMgZGVmYXVsdHMsIF9nZXREZWZhdWx0cyBhcyBnZXREZWZhdWx0cywgbGV4ZXIsIG1hcmtlZCwgb3B0aW9ucywgcGFyc2UsIHBhcnNlSW5saW5lLCBwYXJzZXIsIHNldE9wdGlvbnMsIHVzZSwgd2Fsa1Rva2VucyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFya2VkLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfZ2V0RGVmYXVsdHMiLCJhc3luYyIsImJyZWFrcyIsImV4dGVuc2lvbnMiLCJnZm0iLCJob29rcyIsInBlZGFudGljIiwicmVuZGVyZXIiLCJzaWxlbnQiLCJ0b2tlbml6ZXIiLCJ3YWxrVG9rZW5zIiwiX2RlZmF1bHRzIiwiY2hhbmdlRGVmYXVsdHMiLCJuZXdEZWZhdWx0cyIsImVzY2FwZVRlc3QiLCJlc2NhcGVSZXBsYWNlIiwiUmVnRXhwIiwic291cmNlIiwiZXNjYXBlVGVzdE5vRW5jb2RlIiwiZXNjYXBlUmVwbGFjZU5vRW5jb2RlIiwiZXNjYXBlUmVwbGFjZW1lbnRzIiwiZ2V0RXNjYXBlUmVwbGFjZW1lbnQiLCJjaCIsImVzY2FwZSIsImh0bWwiLCJlbmNvZGUiLCJ0ZXN0IiwicmVwbGFjZSIsInVuZXNjYXBlVGVzdCIsInVuZXNjYXBlIiwiXyIsIm4iLCJ0b0xvd2VyQ2FzZSIsImNoYXJBdCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInBhcnNlSW50Iiwic3Vic3RyaW5nIiwiY2FyZXQiLCJlZGl0IiwicmVnZXgiLCJvcHQiLCJvYmoiLCJuYW1lIiwidmFsIiwiZ2V0UmVnZXgiLCJjbGVhblVybCIsImhyZWYiLCJlbmNvZGVVUkkiLCJlIiwibm9vcFRlc3QiLCJleGVjIiwic3BsaXRDZWxscyIsInRhYmxlUm93IiwiY291bnQiLCJyb3ciLCJtYXRjaCIsIm9mZnNldCIsInN0ciIsImVzY2FwZWQiLCJjdXJyIiwiY2VsbHMiLCJzcGxpdCIsImkiLCJ0cmltIiwic2hpZnQiLCJsZW5ndGgiLCJwb3AiLCJzcGxpY2UiLCJwdXNoIiwicnRyaW0iLCJjIiwiaW52ZXJ0IiwibCIsInN1ZmZMZW4iLCJjdXJyQ2hhciIsInNsaWNlIiwiZmluZENsb3NpbmdCcmFja2V0IiwiYiIsImluZGV4T2YiLCJsZXZlbCIsIm91dHB1dExpbmsiLCJjYXAiLCJsaW5rIiwicmF3IiwibGV4ZXIiLCJ0aXRsZSIsInRleHQiLCJzdGF0ZSIsImluTGluayIsInRva2VuIiwidHlwZSIsInRva2VucyIsImlubGluZVRva2VucyIsImluZGVudENvZGVDb21wZW5zYXRpb24iLCJtYXRjaEluZGVudFRvQ29kZSIsImluZGVudFRvQ29kZSIsIm1hcCIsIm5vZGUiLCJtYXRjaEluZGVudEluTm9kZSIsImluZGVudEluTm9kZSIsImpvaW4iLCJfVG9rZW5pemVyIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwic3BhY2UiLCJzcmMiLCJydWxlcyIsImJsb2NrIiwibmV3bGluZSIsImNvZGUiLCJjb2RlQmxvY2tTdHlsZSIsImZlbmNlcyIsImxhbmciLCJpbmxpbmUiLCJfZXNjYXBlcyIsImhlYWRpbmciLCJ0cmltbWVkIiwiZGVwdGgiLCJociIsImJsb2NrcXVvdGUiLCJ0b3AiLCJibG9ja1Rva2VucyIsImxpc3QiLCJidWxsIiwiaXNvcmRlcmVkIiwib3JkZXJlZCIsInN0YXJ0IiwibG9vc2UiLCJpdGVtcyIsIml0ZW1SZWdleCIsIml0ZW1Db250ZW50cyIsImVuZHNXaXRoQmxhbmtMaW5lIiwiZW5kRWFybHkiLCJsaW5lIiwidCIsInJlcGVhdCIsIm5leHRMaW5lIiwiaW5kZW50IiwidHJpbVN0YXJ0Iiwic2VhcmNoIiwiYmxhbmtMaW5lIiwibmV4dEJ1bGxldFJlZ2V4IiwiTWF0aCIsIm1pbiIsImhyUmVnZXgiLCJmZW5jZXNCZWdpblJlZ2V4IiwiaGVhZGluZ0JlZ2luUmVnZXgiLCJyYXdMaW5lIiwiaXN0YXNrIiwiaXNjaGVja2VkIiwidGFzayIsImNoZWNrZWQiLCJ0cmltRW5kIiwic3BhY2VycyIsImZpbHRlciIsImhhc011bHRpcGxlTGluZUJyZWFrcyIsInNvbWUiLCJwcmUiLCJkZWYiLCJ0YWciLCJ0YWJsZSIsIml0ZW0iLCJoZWFkZXIiLCJhbGlnbiIsInJvd3MiLCJqIiwiayIsImxoZWFkaW5nIiwicGFyYWdyYXBoIiwiaW5SYXdCbG9jayIsInRyaW1tZWRVcmwiLCJydHJpbVNsYXNoIiwibGFzdFBhcmVuSW5kZXgiLCJsaW5rTGVuIiwicmVmbGluayIsImxpbmtzIiwibm9saW5rIiwiZW1TdHJvbmciLCJtYXNrZWRTcmMiLCJwcmV2Q2hhciIsImxEZWxpbSIsIm5leHRDaGFyIiwicHVuY3R1YXRpb24iLCJsTGVuZ3RoIiwickRlbGltIiwickxlbmd0aCIsImRlbGltVG90YWwiLCJtaWREZWxpbVRvdGFsIiwiZW5kUmVnIiwickRlbGltQXN0IiwickRlbGltVW5kIiwibGFzdEluZGV4IiwibGFzdENoYXJMZW5ndGgiLCJpbmRleCIsImNvZGVzcGFuIiwiaGFzTm9uU3BhY2VDaGFycyIsImhhc1NwYWNlQ2hhcnNPbkJvdGhFbmRzIiwiYnIiLCJkZWwiLCJhdXRvbGluayIsInVybCIsInByZXZDYXBaZXJvIiwiX2JhY2twZWRhbCIsImlubGluZVRleHQiLCJfcGFyYWdyYXBoIiwiX2xhYmVsIiwiX3RpdGxlIiwiYnVsbGV0IiwibGlzdEl0ZW1TdGFydCIsIl90YWciLCJfY29tbWVudCIsIm5vcm1hbCIsInJlZmxpbmtTZWFyY2giLCJfcHVuY3R1YXRpb24iLCJibG9ja1NraXAiLCJhbnlQdW5jdHVhdGlvbiIsIl9zY2hlbWUiLCJfZW1haWwiLCJfYXR0cmlidXRlIiwiX2hyZWYiLCJzdHJvbmciLCJtaWRkbGUiLCJlbmRBc3QiLCJlbmRVbmQiLCJlbSIsIl9leHRlbmRlZF9lbWFpbCIsIl9MZXhlciIsIk9iamVjdCIsImNyZWF0ZSIsImlubGluZVF1ZXVlIiwibGV4IiwibGV4SW5saW5lIiwibmV4dCIsImxlYWRpbmciLCJ0YWJzIiwibGFzdFRva2VuIiwiY3V0U3JjIiwibGFzdFBhcmFncmFwaENsaXBwZWQiLCJleHRUb2tlbml6ZXIiLCJjYWxsIiwic3RhcnRCbG9jayIsInN0YXJ0SW5kZXgiLCJJbmZpbml0eSIsInRlbXBTcmMiLCJ0ZW1wU3RhcnQiLCJmb3JFYWNoIiwiZ2V0U3RhcnRJbmRleCIsImVyck1zZyIsImNoYXJDb2RlQXQiLCJjb25zb2xlIiwiZXJyb3IiLCJFcnJvciIsImtlZXBQcmV2Q2hhciIsImtleXMiLCJpbmNsdWRlcyIsImxhc3RJbmRleE9mIiwic3RhcnRJbmxpbmUiLCJfUmVuZGVyZXIiLCJpbmZvc3RyaW5nIiwicXVvdGUiLCJib2R5Iiwic3RhcnRhdHQiLCJsaXN0aXRlbSIsImNoZWNrYm94IiwidGFibGVyb3ciLCJjb250ZW50IiwidGFibGVjZWxsIiwiZmxhZ3MiLCJjbGVhbkhyZWYiLCJvdXQiLCJpbWFnZSIsIl9UZXh0UmVuZGVyZXIiLCJfUGFyc2VyIiwidGV4dFJlbmRlcmVyIiwicGFyc2UiLCJwYXJzZXIiLCJwYXJzZUlubGluZSIsInJlbmRlcmVycyIsImdlbmVyaWNUb2tlbiIsInJldCIsImhlYWRpbmdUb2tlbiIsImNvZGVUb2tlbiIsInRhYmxlVG9rZW4iLCJjZWxsIiwiYmxvY2txdW90ZVRva2VuIiwibGlzdFRva2VuIiwiaXRlbUJvZHkiLCJ1bnNoaWZ0IiwiaHRtbFRva2VuIiwicGFyYWdyYXBoVG9rZW4iLCJ0ZXh0VG9rZW4iLCJlc2NhcGVUb2tlbiIsInRhZ1Rva2VuIiwibGlua1Rva2VuIiwiaW1hZ2VUb2tlbiIsInN0cm9uZ1Rva2VuIiwiZW1Ub2tlbiIsImNvZGVzcGFuVG9rZW4iLCJkZWxUb2tlbiIsIl9Ib29rcyIsInBhc3NUaHJvdWdoSG9va3MiLCJTZXQiLCJwcmVwcm9jZXNzIiwibWFya2Rvd24iLCJwb3N0cHJvY2VzcyIsIk1hcmtlZCIsImFyZ3MiLCJkZWZhdWx0cyIsInNldE9wdGlvbnMiLCJwYXJzZU1hcmtkb3duIiwiUGFyc2VyIiwiUmVuZGVyZXIiLCJUZXh0UmVuZGVyZXIiLCJMZXhlciIsIlRva2VuaXplciIsIkhvb2tzIiwidXNlIiwiY2FsbGJhY2siLCJ2YWx1ZXMiLCJjb25jYXQiLCJjaGlsZFRva2VucyIsInBhY2siLCJvcHRzIiwiZXh0IiwicHJldlJlbmRlcmVyIiwiYXBwbHkiLCJleHRMZXZlbCIsInByb3AiLCJyZW5kZXJlckZ1bmMiLCJyZW5kZXJlcktleSIsInRva2VuaXplckZ1bmMiLCJ0b2tlbml6ZXJLZXkiLCJwcmV2VG9rZW5pemVyIiwiaG9va3NGdW5jIiwiaG9va3NLZXkiLCJwcmV2SG9vayIsImhhcyIsImFyZyIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsInBhY2tXYWxrdG9rZW5zIiwib3JpZ09wdCIsIndhcm4iLCJ0aHJvd0Vycm9yIiwib25FcnJvciIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiYWxsIiwiY2F0Y2giLCJtZXNzYWdlIiwibXNnIiwicmVqZWN0IiwibWFya2VkSW5zdGFuY2UiLCJtYXJrZWQiLCJnZXREZWZhdWx0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/marked@10.0.0/node_modules/marked/lib/marked.esm.js\n");

/***/ })

};
;